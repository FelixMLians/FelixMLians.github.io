<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Felix&#39;s  Space</title>
    <link>http://felixmlians.github.io/post/</link>
    <description>Recent content in Posts on Felix&#39;s  Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012 - 2018, Felix M Lians; all rights reserved.</copyright>
    <lastBuildDate>Sat, 17 Oct 2015 11:11:33 +0120</lastBuildDate>
    <atom:link href="http://felixmlians.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>缓存算法-LRU</title>
      <link>http://felixmlians.github.io/2015/10/17/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95-lru/</link>
      <pubDate>Sat, 17 Oct 2015 11:11:33 +0120</pubDate>
      
      <guid>http://felixmlians.github.io/2015/10/17/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95-lru/</guid>
      <description>

&lt;h2 id=&#34;1-fifo算法:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;1，FIFO算法&lt;/h2&gt;

&lt;p&gt;FIFO（First in First out），先进先出。
在FIFO Cache设计中，核心原则就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。在FIFO Cache中应该支持以下操作;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;get(key)：如果Cache中存在该key，则返回对应的value值，否则，返回-1；&lt;/li&gt;
&lt;li&gt;set(key,value)：如果Cache中存在该key，则重置value值；如果不存在该key，则将该key插入到到Cache中，若Cache已满，则淘汰最早进入Cache的数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以利用一个双向链表保存数据，当来了新的数据之后便添加到链表末尾，如果Cache存满数据，则把链表头部数据删除，然后把新的数据添加到链表末尾。在访问数据的时候，如果在Cache中存在该数据的话，则返回对应的value值；否则返回-1。如果想提高访问效率，可以利用hashmap来保存每个key在链表中对应的位置。　　&lt;/p&gt;

&lt;h2 id=&#34;2-lfu算法:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;2，LFU算法&lt;/h2&gt;

&lt;p&gt;LFU（Least Frequently Used）最近最少使用算法。它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。&lt;/p&gt;

&lt;p&gt;注意LFU和LRU算法的不同之处，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;get(key)：如果Cache中存在该key，则返回对应的value值，否则，返回-1；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set(key,value)：如果Cache中存在该key，则重置value值；如果不存在该key，则将该key插入到到Cache中，若Cache已满，则淘汰最少访问的数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了能够淘汰最少使用的数据，因此LFU算法最简单的一种设计思路就是：&lt;/p&gt;

&lt;p&gt;利用一个数组存储 数据项，用hashmap存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。&lt;/p&gt;

&lt;p&gt;这样一来的话，在插入数据和访问数据的时候都能达到O(1)的时间复杂度，&lt;/p&gt;

&lt;p&gt;在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为O(n)。
　　&lt;/p&gt;

&lt;h2 id=&#34;3-lru算法:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;3，LRU算法&lt;/h2&gt;

&lt;p&gt;LRU（Least
Recently Used）算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。&lt;/p&gt;

&lt;p&gt;那就是利用链表和hashmap。&lt;/p&gt;

&lt;p&gt;当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。&lt;/p&gt;

&lt;p&gt;在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。&lt;/p&gt;

&lt;p&gt;可以利用双向链表，并提供head指针和tail指针，这样一来，所有的操作都是O(1)时间复杂度。&lt;/p&gt;

&lt;h2 id=&#34;4-其他算法-引用-http-www-leexiang-com-cache-algorithm-http-www-leexiang-com-cache-algorithm:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;4, 其他算法 （引用：&lt;a href=&#34;http://www.leexiang.com/cache-algorithm&#34;&gt;http://www.leexiang.com/cache-algorithm&lt;/a&gt;）&lt;/h2&gt;

&lt;h5 id=&#34;least-recently-used-2-lru2:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Least Recently Used 2（LRU2）：&lt;/h5&gt;

&lt;p&gt;　　我是 Least Recently Used 2，有人叫我最近最少使用 twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他们还没有被第二次读取。我比LRU好，而且是 adoptive to access 模式 。&lt;/p&gt;

&lt;h5 id=&#34;two-queues-2q:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Two Queues（2Q）：&lt;/h5&gt;

&lt;p&gt;　　我是 Two Queues；我把被访问的数据放到 LRU 的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的 LRU 缓存。&lt;/p&gt;

&lt;p&gt;　　我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把 LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是 LRU 家族中的一员，而且是 adoptive to access 模式 。&lt;/p&gt;

&lt;h5 id=&#34;adaptive-replacement-cache-arc:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Adaptive Replacement Cache（ARC）：&lt;/h5&gt;

&lt;p&gt;　　我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU 组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个 LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而 L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU 之间的，不过没关系，我不介意。&lt;/p&gt;

&lt;p&gt;　　我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。&lt;/p&gt;

&lt;h5 id=&#34;most-recently-used-mru:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Most Recently Used（MRU）：&lt;/h5&gt;

&lt;p&gt;　　我是 MRU，和 LRU 是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。&lt;/p&gt;

&lt;p&gt;　　我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！&lt;/p&gt;

&lt;h5 id=&#34;second-chance:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Second Chance：&lt;/h5&gt;

&lt;p&gt;　　大家好，我是 second chance，我是通过 FIFO 修改而来的，被大家叫做 second chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO 一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个 bit 表示），没有没有被使用过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比 FIFO 快。&lt;/p&gt;

&lt;h5 id=&#34;clock:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;CLock：&lt;/h5&gt;

&lt;p&gt;　　我是 Clock，一个更好的 FIFO，也比 second chance 更好。因为我不会像 second chance 那样把有标志的缓存对象放到队列的尾部，但是也可以达到 second chance 的效果。&lt;/p&gt;

&lt;p&gt;　　我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存 miss 发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对象能够被放入。我比 second chance 更快。&lt;/p&gt;

&lt;h5 id=&#34;simple-time-based:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Simple time-based：&lt;/h5&gt;

&lt;p&gt;　　我是 simple time-based 缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。&lt;/p&gt;

&lt;h5 id=&#34;extended-time-based-expiration:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Extended time-based expiration：&lt;/h5&gt;

&lt;p&gt;　　我是 extended time-based expiration 缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。&lt;/p&gt;

&lt;h5 id=&#34;sliding-time-based-expiration:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Sliding time-based expiration：&lt;/h5&gt;

&lt;p&gt;　　我是 sliding time-based expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。&lt;/p&gt;

&lt;h5 id=&#34;random-cache:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;Random Cache&lt;/h5&gt;

&lt;p&gt;　　我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比 FIFO 机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。
　　&lt;/p&gt;

&lt;h5 id=&#34;其他的缓存算法还考虑到了下面几点:4850f5edee4f0413e1f2784d2d302be6&#34;&gt;其他的缓存算法还考虑到了下面几点：&lt;/h5&gt;

&lt;p&gt;　　成本：如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。&lt;/p&gt;

&lt;p&gt;　　容量：如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。&lt;/p&gt;

&lt;p&gt;　　时间：一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。&lt;/p&gt;

&lt;p&gt;　　根据缓存对象的大小而不管其他的缓存算法可能是有必要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React入门-002</title>
      <link>http://felixmlians.github.io/2015/09/24/react%E5%85%A5%E9%97%A8-002/</link>
      <pubDate>Thu, 24 Sep 2015 22:20:19 +0120</pubDate>
      
      <guid>http://felixmlians.github.io/2015/09/24/react%E5%85%A5%E9%97%A8-002/</guid>
      <description>

&lt;h3 id=&#34;1-proptypes:59590282874bf473b9caec61cb37403d&#34;&gt;1，PropTypes&lt;/h3&gt;

&lt;p&gt;组件的属性可以接受任意值，字符串、对象、函数等等都可以。
组件类的PropTypes属性是用来验证组件实例的属性是否符合要求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyTitle = React.createClass({
  propTypes: {
title: React.PropTypes.string.isRequired,
  },

  render: function() {
 return &amp;lt;h1&amp;gt; {this.props.title} &amp;lt;/h1&amp;gt;;
   }
});

var title = &amp;quot;hello&amp;quot;;

ReactDOM.render(
  &amp;lt;MyTitle title={title} /&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getDefaultProps&lt;/code&gt; 方法可以用来设置组件属性的默认值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyTitle = React.createClass({
  getDefaultProps : function () {
return {
  title : &#39;Hello World&#39;
};
  },

  render: function() {
 return &amp;lt;h1&amp;gt; {this.props.title} &amp;lt;/h1&amp;gt;;
   }
});

ReactDOM.render(
  &amp;lt;MyTitle /&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-获取真实的dom节点:59590282874bf473b9caec61cb37403d&#34;&gt;2，获取真实的DOM节点&lt;/h3&gt;

&lt;p&gt;组件并不是真实的 &lt;code&gt;DOM&lt;/code&gt; 节点，而是存在于内存之中的一种数据结构，叫做&lt;code&gt;虚拟 DOM （virtual DOM）&lt;/code&gt;。只有当它插入文档以后，才会变成真实的 &lt;code&gt;DOM&lt;/code&gt; 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 &lt;code&gt;DOM diff&lt;/code&gt; ，它可以极大提高网页的性能表现。
但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 &lt;code&gt;ref&lt;/code&gt; 属性:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyComponent = React.createClass({
  handleClick: function() {
this.refs.myTextInput.focus();
  },
  render: function() {
return (
  &amp;lt;div&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; ref=&amp;quot;myTextInput&amp;quot; /&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Focus the text input&amp;quot; onClick={this.handleClick} /&amp;gt;
  &amp;lt;/div&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;MyComponent /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组件 &lt;code&gt;MyComponent&lt;/code&gt; 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 &lt;code&gt;DOM&lt;/code&gt; 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 &lt;code&gt;ref&lt;/code&gt; 属性，然后 &lt;code&gt;this.refs.[refName]&lt;/code&gt; 就会返回这个真实的 &lt;code&gt;DOM&lt;/code&gt; 节点。
需要注意的是，由于 &lt;code&gt;this.refs.[refName]&lt;/code&gt; 属性获取的是真实 &lt;code&gt;DOM&lt;/code&gt; ，所以必须等到虚拟 &lt;code&gt;DOM&lt;/code&gt; 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 &lt;code&gt;Clic&lt;/code&gt;k 事件的回调函数，确保了只有等到真实 &lt;code&gt;DOM&lt;/code&gt; 发生 &lt;code&gt;Click&lt;/code&gt; 事件之后，才会读取 &lt;code&gt;this.refs.[refName]&lt;/code&gt; 属性。
React 组件支持很多事件，除了 &lt;code&gt;Click&lt;/code&gt; 事件以外，还有 &lt;code&gt;KeyDown&lt;/code&gt; 、&lt;code&gt;Copy&lt;/code&gt;、&lt;code&gt;Scroll&lt;/code&gt; 等;&lt;/p&gt;

&lt;h3 id=&#34;3-this-state:59590282874bf473b9caec61cb37403d&#34;&gt;3，this.state&lt;/h3&gt;

&lt;p&gt;React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var LikeButton = React.createClass({
  getInitialState: function() {
return {liked: false};
  },
  handleClick: function(event) {
this.setState({liked: !this.state.liked});
  },
  render: function() {
var text = this.state.liked ? &#39;like&#39; : &#39;haven\&#39;t liked&#39;;
return (
  &amp;lt;p onClick={this.handleClick}&amp;gt;
You {text} this. Click to toggle.
  &amp;lt;/p&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;LikeButton /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个 LikeButton 组件，它的 &lt;code&gt;getInitialState&lt;/code&gt; 方法用于定义初始状态，也就是一个对象，这个对象可以通过 &lt;code&gt;this.state&lt;/code&gt; 属性读取。当用户点击组件，导致状态变化，&lt;code&gt;this.setState&lt;/code&gt; 方法就修改状态值，每次修改以后，自动调用 &lt;code&gt;this.render&lt;/code&gt; 方法，再次渲染组件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this.props&lt;/code&gt; 表示那些一旦定义，就不再改变的特性，而 &lt;code&gt;this.state&lt;/code&gt; 是会随着用户互动而产生变化的特性;&lt;/p&gt;

&lt;h3 id=&#34;4-表单:59590282874bf473b9caec61cb37403d&#34;&gt;4, 表单&lt;/h3&gt;

&lt;p&gt;用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Input = React.createClass({
  getInitialState: function() {
return {value: &#39;Hello!&#39;};
  },
  handleChange: function(event) {
this.setState({value: event.target.value});
  },
  render: function () {
var value = this.state.value;
return (
  &amp;lt;div&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; value={value} onChange={this.handleChange} /&amp;gt;
&amp;lt;p&amp;gt;{value}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
);
  }
});

ReactDOM.render(&amp;lt;Input/&amp;gt;, document.body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文本输入框的值，不能用 this.props.value 读取，而要定义一个 &lt;code&gt;onChange&lt;/code&gt; 事件的回调函数，通过 &lt;code&gt;event.target.value&lt;/code&gt; 读取用户输入的值。&lt;code&gt;textarea&lt;/code&gt; 元素、&lt;code&gt;select&lt;/code&gt;元素、&lt;code&gt;radio&lt;/code&gt;元素都属于这种情况;&lt;/p&gt;

&lt;h3 id=&#34;5-组件的生命周期:59590282874bf473b9caec61cb37403d&#34;&gt;5，组件的生命周期&lt;/h3&gt;

&lt;p&gt;组件的生命周期分成三个状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Mounting：已插入真实 DOM
* Updating：正在被重新渲染
* Unmounting：已移出真实 DOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- componentWillMount()
- componentDidMount()
- componentWillUpdate(object nextProps, object nextState)
- componentDidUpdate(object prevProps, object prevState)
- componentWillUnmount()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，React 还提供两种特殊状态的处理函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用
- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Hello = React.createClass({
  getInitialState: function () {
return {
  opacity: 1.0
};
  },

  componentDidMount: function () {
this.timer = setInterval(function () {
  var opacity = this.state.opacity;
  opacity -= .05;
  if (opacity &amp;lt; 0.1) {
opacity = 1.0;
  }
  this.setState({
opacity: opacity
  });
}.bind(this), 100);
  },

  render: function () {
return (
  &amp;lt;div style={{opacity: this.state.opacity}}&amp;gt;
Hello {this.props.name}
  &amp;lt;/div&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;Hello name=&amp;quot;world&amp;quot;/&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组件的style属性的设置方式，这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React入门-001</title>
      <link>http://felixmlians.github.io/2015/09/09/react%E5%85%A5%E9%97%A8-001/</link>
      <pubDate>Wed, 09 Sep 2015 22:09:30 +0900</pubDate>
      
      <guid>http://felixmlians.github.io/2015/09/09/react%E5%85%A5%E9%97%A8-001/</guid>
      <description>

&lt;p&gt;鉴于iOS行情的不好，而且越来越多的公司要求web app和hybrid app的开发。最近发觉React非常的热门，看上去充满希望，当然应该好好学一下。从技术角度，可以满足好奇心，提高技术水平；从职业角度，有利于求职和晋升，有利于参与潜力大的项目。&lt;/p&gt;

&lt;p&gt;于是在github上下载了入门的React Demo,开始入门学习！&lt;/p&gt;

&lt;p&gt;其中React地址 &lt;a href=&#34;https://github.com/facebook/react&#34;&gt;https://github.com/facebook/react&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;React Demo 地址：&lt;a href=&#34;https://github.com/ruanyf/react-demos&#34;&gt;https://github.com/ruanyf/react-demos&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;1-html模板:c427717cf2c20ae79dea8b34898d617a&#34;&gt;1，HTML模板&lt;/h2&gt;

&lt;p&gt;React的网页源码，结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
&amp;lt;script src=&amp;quot;../build/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;../build/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;../build/browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;
  // ** Our code goes here! **
&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最后一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签的 &lt;code&gt;type&lt;/code&gt; 属性为 &lt;code&gt;text/babel&lt;/code&gt; 。这是因为 &lt;code&gt;React&lt;/code&gt; 独有的 &lt;code&gt;JSX&lt;/code&gt; 语法，跟 &lt;code&gt;JavaScript&lt;/code&gt; 不兼容。凡是使用 &lt;code&gt;JSX&lt;/code&gt; 的地方，都要加上 &lt;code&gt;type=&amp;quot;text/babel&amp;quot;&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上面代码一共用了三个库：&lt;code&gt;react.js&lt;/code&gt; 、&lt;code&gt;react-dom.js&lt;/code&gt; 和 &lt;code&gt;Browser.js&lt;/code&gt; ，它们必须首先加载。其中，&lt;code&gt;react.js&lt;/code&gt; 是&lt;code&gt;React&lt;/code&gt; 的核心库，&lt;code&gt;react-dom.js&lt;/code&gt; 是提供与 &lt;code&gt;DOM&lt;/code&gt; 相关的功能，&lt;code&gt;Browser.js&lt;/code&gt; 的作用是将 &lt;code&gt;JSX&lt;/code&gt; 语法转为 &lt;code&gt;JavaScript&lt;/code&gt; 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ babel src --out-dir build&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。&lt;/p&gt;

&lt;h2 id=&#34;2-reactdom-render:c427717cf2c20ae79dea8b34898d617a&#34;&gt;2，ReactDOM.render()&lt;/h2&gt;

&lt;p&gt;ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ReactDOM.render(
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码将一个 h1 标题，插入 example 节点;&lt;/p&gt;

&lt;h2 id=&#34;3-jsx-语法:c427717cf2c20ae79dea8b34898d617a&#34;&gt;3，JSX 语法&lt;/h2&gt;

&lt;p&gt;HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写:&lt;/p&gt;

&lt;p&gt;var names = [&amp;lsquo;Alice&amp;rsquo;, &amp;lsquo;Emily&amp;rsquo;, &amp;lsquo;Kate&amp;rsquo;];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ReactDOM.render(
  &amp;lt;div&amp;gt;
  {
names.map(function (name) {
  return &amp;lt;div&amp;gt;Hello, {name}!&amp;lt;/div&amp;gt;
})
  }
  &amp;lt;/div&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSX 的基本语法规则：遇到 &lt;code&gt;HTML&lt;/code&gt; 标签（以&lt;code&gt;&amp;lt;&lt;/code&gt; 开头），就用 &lt;code&gt;HTML&lt;/code&gt; 规则解析；遇到代码块（以&lt;code&gt;{&lt;/code&gt; 开头），就用 &lt;code&gt;JavaScript&lt;/code&gt; 规则解析。&lt;/p&gt;

&lt;p&gt;JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [
  &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;,
  &amp;lt;h2&amp;gt;React is awesome&amp;lt;/h2&amp;gt;,
];
ReactDOM.render(
  &amp;lt;div&amp;gt;{arr}&amp;lt;/div&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-组件:c427717cf2c20ae79dea8b34898d617a&#34;&gt;4, 组件&lt;/h2&gt;

&lt;p&gt;React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var HelloMessage = React.createClass({
  render: function() {
return &amp;lt;h1&amp;gt;Hello {this.props.name}&amp;lt;/h1&amp;gt;;
  }
});

ReactDOM.render(
  &amp;lt;HelloMessage name=&amp;quot;John&amp;quot; /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量 &lt;code&gt;HelloMessage&lt;/code&gt; 就是一个组件类。模板插入 &lt;code&gt;&amp;lt;HelloMessage /&amp;gt;&lt;/code&gt; 时，会自动生成 &lt;code&gt;HelloMessage&lt;/code&gt; 的一个实例（下文的&amp;rdquo;组件&amp;rdquo;都指组件类的实例）。所有组件类都必须有自己的 &lt;code&gt;render&lt;/code&gt; 方法，用于输出组件。
注意，组件类的第一个字母必须&lt;strong&gt;大写&lt;/strong&gt;，否则会报错，比如&lt;code&gt;HelloMessage&lt;/code&gt;不能写成&lt;code&gt;helloMessage&lt;/code&gt;。另外，组件类只能包含一个*顶层标签*，否则也会报错。&lt;/p&gt;

&lt;p&gt;组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;code&gt;&amp;lt;HelloMessage name=&amp;quot;John&amp;quot;&amp;gt;&lt;/code&gt; ，就是 &lt;code&gt;HelloMessage&lt;/code&gt; 组件加入一个 &lt;code&gt;name&lt;/code&gt; 属性，值为 &lt;code&gt;John&lt;/code&gt;。组件的属性可以在组件类的 &lt;code&gt;this.props&lt;/code&gt; 对象上获取。&lt;/p&gt;

&lt;p&gt;添加组件属性，有一个地方需要注意，就是 class 属性需要写成 &lt;code&gt;className&lt;/code&gt; ，for 属性需要写成 &lt;code&gt;htmlFor&lt;/code&gt; ，这是因为 class 和 for 是 JavaScript 的保留字。&lt;/p&gt;

&lt;h2 id=&#34;5-this-props-children:c427717cf2c20ae79dea8b34898d617a&#34;&gt;5，this.props.children&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;this.props&lt;/code&gt; 对象的属性与组件的属性一一对应，但是有一个例外，就是 &lt;code&gt;this.props.children&lt;/code&gt; 属性。它表示组件的所有子节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var NotesList = React.createClass({
  render: function() {
return (
  &amp;lt;ol&amp;gt;
  {
React.Children.map(this.props.children, function (child) {
  return &amp;lt;li&amp;gt;{child}&amp;lt;/li&amp;gt;;
})
  }
  &amp;lt;/ol&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;NotesList&amp;gt;
&amp;lt;span&amp;gt;hello&amp;lt;/span&amp;gt;
&amp;lt;span&amp;gt;world&amp;lt;/span&amp;gt;
  &amp;lt;/NotesList&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的 &lt;code&gt;NoteList&lt;/code&gt; 组件有两个 &lt;code&gt;span&lt;/code&gt; 子节点，它们都可以通过 &lt;code&gt;this.props.children&lt;/code&gt; 读取；&lt;/p&gt;

&lt;p&gt;这里需要注意， &lt;code&gt;this.props.children&lt;/code&gt; 的值有三种可能：如果当前组件没有子节点，它就是 &lt;code&gt;undefined&lt;/code&gt; ;如果有一个子节点，数据类型是 &lt;code&gt;object&lt;/code&gt; ；如果有多个子节点，数据类型就是 &lt;code&gt;array&lt;/code&gt; 。所以，处理 &lt;code&gt;this.props.children&lt;/code&gt; 的时候要小心。
React 提供一个工具方法 &lt;code&gt;React.Children&lt;/code&gt; 来处理 &lt;code&gt;this.props.children&lt;/code&gt; 。我们可以用 &lt;code&gt;React.Children.map&lt;/code&gt; 来遍历子节点，而不用担心 &lt;code&gt;this.props.children&lt;/code&gt; 的数据类型是 &lt;code&gt;undefined&lt;/code&gt; 还是 &lt;code&gt;object&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS 多线程锁</title>
      <link>http://felixmlians.github.io/2015/08/27/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</link>
      <pubDate>Thu, 27 Aug 2015 17:35:29 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/08/27/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</guid>
      <description>

&lt;h4 id=&#34;dispatch-semaphore:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;dispatch_semaphore&lt;/h4&gt;

&lt;p&gt;信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），直至计数器大于零，然后线程会减少这个计数。&lt;/p&gt;

&lt;p&gt;在GCD中有三个函数是semaphore的操作，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dispatch_semaphore_create　　　创建一个semaphore&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_signal　　　发送一个信号&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_wait　　　　等待信号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;是发送一个信号，自然会让信号总量加1，&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_t group = dispatch_group_create();   
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);   
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   
    for (int i = 0; i &amp;lt; 100; i++)   
    {   
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   
        dispatch_group_async(group, queue, ^{   
            NSLog(@&amp;quot;%i&amp;quot;,i);   
            sleep(2);   
            dispatch_semaphore_signal(semaphore);   
        });   
    }   
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);   
    dispatch_release(group);   
    dispatch_release(semaphore);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码创建了一个初使值为10的semaphore，每一次for循环都会创建一个新的线程，线程结束的时候会发送一个信号，线程创建之前会信号等待，所以当同时创建了10个线程之后，for循环就会阻塞，等待有线程结束之后会增加一个信号才继续执行，如此就形成了对并发的控制，如上就是一个并发数为10的一个线程队列。&lt;/p&gt;

&lt;h4 id=&#34;pthread-mutex-t:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;pthread_mutex_t&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_NORMAL，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_ERRORCHECK，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型是 PTHREAD_MUTEX_DEFAULT，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;amp;mutex, NULL);

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;amp;mutex);
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;amp;mutex);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;synchronized:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;@synchronized&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nslock:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];
NSLock *lock = [[NSLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;

&lt;h4 id=&#34;nsrecursivelock:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSRecursiveLock&lt;/h4&gt;

&lt;p&gt;NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    static void (^RecursiveMethod)(int);
 
    RecursiveMethod = ^(int value) {
 
        [lock lock];
        if (value &amp;gt; 0) {
 
            NSLog(@&amp;quot;value = %d&amp;quot;, value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };
 
    RecursiveMethod(5);
});
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    sleep(2);
    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];
    if (flag) {
        NSLog(@&amp;quot;lock before date&amp;quot;);
 
        [lock unlock];
    } else {
        NSLog(@&amp;quot;fail to lock before date&amp;quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSRecursiveLock除了实现NSLocking协议的方法外，还提供了两个方法，分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在给定的时间之前去尝试请求一个锁
- (BOOL)lockBeforeDate:(NSDate *)limit
 
// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功
- (BOOL)tryLock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，NSRecursiveLock还声明了一个name属性，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property(copy) NSString *name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用这个字符串来标识一个锁。Cocoa也会使用这个name作为错误描述信息的一部分。&lt;/p&gt;

&lt;h4 id=&#34;nscondition:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSCondition&lt;/h4&gt;

&lt;p&gt;使用NSCondition，实现多线程的同步，即，可实现生产者消费者问题。&lt;/p&gt;

&lt;p&gt;基本思路是，首先要创建公用的NSCondition实例。然后：&lt;/p&gt;

&lt;p&gt;消费者取得锁，取产品，如果没有，则wait，这时会释放锁，直到有线程唤醒它去消费产品；&lt;/p&gt;

&lt;p&gt;生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)conditionTest:(id)sender
{
    NSLog(@&amp;quot;begin condition works!&amp;quot;);
    products = [[NSMutableArray alloc] init];
    condition = [[NSCondition alloc] init];
     
    [NSThread detachNewThreadSelector:@selector(createProducter) toTarget:self withObject:nil];
    [NSThread detachNewThreadSelector:@selector(createConsumenr) toTarget:self withObject:nil];
}
 
- (void)createConsumenr
{
    [condition lock];
    while ([products count] == 0) {
        NSLog(@&amp;quot;wait for products&amp;quot;);
        [condition wait];
    }
    [products removeObjectAtIndex:0];
    NSLog(@&amp;quot;comsume a product&amp;quot;);
    [condition unlock];
}
 
- (void)createProducter
{
    [condition lock];
    [products addObject:[[NSObject alloc] init]];
    NSLog(@&amp;quot;produce a product&amp;quot;);
    [condition signal];
    [condition unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsconditionlock:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSConditionLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
NSConditionLock *theLock = [[NSConditionLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    for (int i=0;i&amp;lt;=2;i++)
    {
        [theLock lock];
        NSLog(@&amp;quot;thread1:%d&amp;quot;,i);
        sleep(2);
        [theLock unlockWithCondition:i];
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [theLock lockWhenCondition:2];
    NSLog(@&amp;quot;thread2&amp;quot;);
    [theLock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsdistributedlock-分布式锁:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSDistributedLock 分布式锁&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>编程小助手 - 学习编程的有效工具</title>
      <link>http://felixmlians.github.io/2015/07/23/%E7%BC%96%E7%A8%8B%E5%B0%8F%E5%8A%A9%E6%89%8B---%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%89%E6%95%88%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 23 Jul 2015 10:47:39 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/07/23/%E7%BC%96%E7%A8%8B%E5%B0%8F%E5%8A%A9%E6%89%8B---%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%89%E6%95%88%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;&lt;strong&gt;编程小助手 - 学习编程的有效工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/bian-cheng-xiao-zhu-shou-xue/id1007208297?mt=8&#34;&gt;https://itunes.apple.com/cn/app/bian-cheng-xiao-zhu-shou-xue/id1007208297?mt=8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4+&lt;/p&gt;

&lt;p&gt;Swift语言如今如火如荼，势头一发不可收拾。作为iOS开发者都应该开始学习swift语言，本软件主要针对Swifter们开发入门，基础知识温故知新的小工具。&lt;/p&gt;

&lt;p&gt;无论你是在坐车途中还是在买单排队，所有细小的时间你都可以充分利用起来，学习充电。&lt;/p&gt;

&lt;p&gt;本工具不仅提供了Swift基础语法，还有详尽的进阶指导资源。&lt;/p&gt;

&lt;p&gt;PS:业余制作，巩固复习下swift语法&lt;/p&gt;

&lt;p&gt;个人博客地址： &lt;a href=&#34;http://felixmlians.github.io/&#34;&gt;http://felixmlians.github.io/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IDFA 3选项释义</title>
      <link>http://felixmlians.github.io/2015/06/11/idfa-3%E9%80%89%E9%A1%B9%E9%87%8A%E4%B9%89/</link>
      <pubDate>Thu, 11 Jun 2015 19:39:50 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/06/11/idfa-3%E9%80%89%E9%A1%B9%E9%87%8A%E4%B9%89/</guid>
      <description>&lt;p&gt;Everything has come to its usual state now. Simply upload your binary as you&amp;rsquo;ve been doing this while, and broadly classify IDFA in two categories:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;publisher: You use third-party ad-networks library to display ad. Choose the 1st option in IDFA -&amp;gt; &amp;ldquo;Serve advertisements within the app&amp;rdquo;. You&amp;rsquo;re a publisher since you show ads, but do not perform advertising for your own app.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Advertiser: You use third-party libraries to track conversions for your app, as well as track &amp;lsquo;goals&amp;rsquo; in your app. You directly do not show ads in your app. Choose the 2nd &amp;amp; 3rd option in IDFA -&amp;gt; &amp;ldquo;Attribute this app installation to a previously served ad&amp;rdquo;. AND &amp;ldquo;Attribute an action taken within this app to a previously served advertisement&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mixed: You track conversions for your app, as well as display ads in your app. Choose all three options.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iOS 砸壳，获取头文件，反编译工具 </title>
      <link>http://felixmlians.github.io/2015/05/21/ios-%E7%A0%B8%E5%A3%B3%E8%8E%B7%E5%8F%96%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 21 May 2015 15:25:47 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/05/21/ios-%E7%A0%B8%E5%A3%B3%E8%8E%B7%E5%8F%96%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AppCrackr,dumpdecrypted
下载地址：&lt;a href=&#34;https://github.com/stefanesser/dumpdecrypted/archive/master.zip&#34;&gt;https://github.com/stefanesser/dumpdecrypted/archive/master.zip&lt;/a&gt;进行砸壳。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用class-dump获取头文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Hopper Disassembler   IDA Pro 进行反编译&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iOS NSDateFormatter </title>
      <link>http://felixmlians.github.io/2015/04/06/ios-nsdateformatter/</link>
      <pubDate>Mon, 06 Apr 2015 23:11:23 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/04/06/ios-nsdateformatter/</guid>
      <description>&lt;p&gt;格式化参数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    G: 公元时代，例如AD公元
    yy: 年的后2位,12
    yyyy: 完整年,2012
    MM: 月，显示为1-12
    MMM: 月，显示为英文月份简写,如 Jan
    MMMM: 月，显示为英文月份全称，如 Janualy
    dd: 日，2位数表示，如02
    d: 日，1-2位显示，如 2
    EEE: 简写星期几，如Sun
    EEEE: 全写星期几，如Sunday
    aa: 上下午，AM/PM
    H: 时，24小时制，0-23
    K：时，12小时制，0-11
    m: 分，1-2位
    mm: 分，2位
    s: 秒，1-2位
    ss: 秒，2位
    S: 毫秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用日期组合：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;yyyy-MM-dd HH:mm:ss.SSS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;yyyy-MM-dd HH:mm:ss&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;yyyy-MM-dd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MM dd yyyy&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS 证书以及迁移到新电脑</title>
      <link>http://felixmlians.github.io/2015/03/01/ios-%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</link>
      <pubDate>Sun, 01 Mar 2015 12:15:44 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/03/01/ios-%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;WARNING：Distribution Certification只有配置证书的电脑才可使用，因此即使导出导出Keychain安装到其他电脑上，其他电脑也不可能具有证书的权限。&lt;strong&gt;（新电脑要发布版本需要重新生成证书）&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;1-certification-证书:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;1. Certification(证书)&lt;/h4&gt;

&lt;p&gt;证书是对电脑开发资格的认证，每个开发者帐号有一套，分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer Certification(开发证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装在电脑上提供权限：开发人员通过设备进行真机测试。
可以生成副本供多台电脑安装；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distribution Certification(发布证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装在电脑上提供发布iOS程序的权限：开发人员可以制做测试版和发布版的程序。&lt;/p&gt;

&lt;p&gt;不可生成副本，仅有配置该证书的电脑才可使用；（副本制做介绍在下面Keychain中介绍）&lt;/p&gt;

&lt;h4 id=&#34;2-provisioning-profile-授权文件:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;2. Provisioning Profile(授权文件)&lt;/h4&gt;

&lt;p&gt;授权文件是对设备如iPod Touch、iPad、iPhone的授权，文件内记录的是设备的UDID和程序的App Id，即：使被授权的设备可以安装或调试Bundle identifier与授权文件中记录的App Id对应的程序。&lt;/p&gt;

&lt;p&gt;开发者帐号在创建授权文件时候会选择App Id，（开发者帐号下App Id中添加，单选）和UDID（开发者帐号下Devices中添加最多100个，多选）。&lt;/p&gt;

&lt;p&gt;授权文件分为两种，对应相应的证书使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer Provisioning Profile(开发授权文件)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在装有开发证书或副本的电脑上使用，开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中，即可进行真机测试。&lt;/p&gt;

&lt;p&gt;注意：确保电脑有权限真机调试，即安装了开发证书或副本；在开发工具中程序的Bundle identifier和选中使用的授权文件的App Id要一致；连接调试的设备的UDID在选中的授权文件中有记录。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distribution Provisioning Profile(发布授权文件)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在装有发布证书的电脑上（即配置证书的电脑，只有一台）制做测试版和发布版的程序。&lt;/p&gt;

&lt;p&gt;发布版就是发布到App Store上的程序文件，开发者帐号创建授权文件时选择store选项，选择App Id，无需选择UDID；&lt;/p&gt;

&lt;p&gt;测试版就是在发布之前交给测试人员可同步到设备上的程序文件，开发者帐号创建授权文件时选择AdHoc，选择App Id和UDID；只有选中的UDID对应的设备才可能安装上通过该授权文件制做的程序。&lt;/p&gt;

&lt;h4 id=&#34;3-keychain-开发密钥:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;3. Keychain(开发密钥)&lt;/h4&gt;

&lt;p&gt;安 装证书成功的情况下证书下都会生成Keychain，上面提到的证书副本（导出证书重新命名）就是通过配置证书的电脑导出Keychain（就是.p12 文件）安装到其他机子上，让其他机子得到证书对应的权限。Developer Certification就可以制做副本Keychain分发到其他电脑上安装，使其可以进行真机测试。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;导出私钥和数字证书是为安全保存和能够在多台电脑上进行工作。打开Keychain Access应用选择’KEY’分类。&lt;/li&gt;
&lt;li&gt;右键点击和你iphone开发证书关联的私钥，并在弹出菜单中选择导出选项。&lt;/li&gt;
&lt;li&gt;使用(.p12)保存包含了你个人信息的钥匙。&lt;/li&gt;
&lt;li&gt;你将会被提示创建一个密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在可以通过.p12文件在不同系统之间传输。双击.p12在其他系统上进行安装。输入你在step4输入的密码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>When you are old</title>
      <link>http://felixmlians.github.io/2015/01/01/when-you-are-old/</link>
      <pubDate>Thu, 01 Jan 2015 00:00:36 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/01/01/when-you-are-old/</guid>
      <description>&lt;p&gt;Another year,so many things changed,so many people left,I don&amp;rsquo;t know what to do,but carry on and on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Viva la vida!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        When you are old and grey and full of sleep
　　　　 And nodding by the fire,take down this book
　　　　 And slowly read,and dream of the soft look
　　　　 Your eyes had once, and of their shadows deep;
　　　　
　　　　 How many loved your moments of glad grace,
　　　　 And loved your beauty with love false or true,
　　　　 But one man loved the pilgrim soul in you,
　　　　 And loved the sorrows of your changing face;
　　　　
　　　　 And bending down beside the glowing bars,
　　　　 Murmur,a little sadly,how love fled
　　　　 And paced upon the mountains overhead
　　　　 And hid his face amid a crowd of stars.
　　
　　(BY William Butler Yeats)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 截屏拼图</title>
      <link>http://felixmlians.github.io/2014/12/22/ios-%E6%88%AA%E5%B1%8F%E6%8B%BC%E5%9B%BE/</link>
      <pubDate>Mon, 22 Dec 2014 11:22:30 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/12/22/ios-%E6%88%AA%E5%B1%8F%E6%8B%BC%E5%9B%BE/</guid>
      <description>

&lt;h4 id=&#34;1-普通界面:793ee16878053e99cf22e48f2d18d892&#34;&gt;1. 普通界面&lt;/h4&gt;

&lt;h5 id=&#34;ios-7-以后截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;ios 7 以后截图&lt;/h5&gt;

&lt;p&gt;ios7中添加了调用 &lt;code&gt;snapshotViewAfterScreenUpdates&lt;/code&gt; 创建一个复合视图的快照。然后返回一个&lt;code&gt;uiview&lt;/code&gt;对象来表示调用视图的整体外观。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Supplying YES for -snapshotViewAfterScreenUpdates: means it needs a trip back to the runloop to actually draw the image. If you supply NO, it will try immediately, but if your view is off screen or otherwise hasn&amp;rsquo;t yet drawn to the screen, the snapshot will be empty.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为返回的是一个view对象,所以,你可以更改它以及它的layer属性.但是呢,你不能够修改它的layer的content属性;如果你试图这么做,将不会有任何效果.如果当前的view还没有渲染,或者这么说吧,因为还没有出现在屏幕上,那么,这个截取的view将不会有能显示的content.&lt;/p&gt;

&lt;p&gt;如果你想要加载一个图形效果,比如blur,请使用这个方法 &lt;code&gt;drawViewHierarchyInRect:afterScreenUpdates:&lt;/code&gt; 来代替.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;quot;UIImage+ImageEffects.h&amp;quot;

- (void)createBlurredSnapshot {
    
    UIGraphicsBeginImageContextWithOptions(self.targetImageView.bounds.size, NO, 0);
    
    BOOL result = [self.sourceImageView drawViewHierarchyInRect:self.targetImageView.bounds afterScreenUpdates:YES];
    
    UIImage *snapshotImage = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    
   if (result)
        self.targetImageView.image = [snapshotImage applyLightEffect];
    else
        NSLog(@&amp;quot;drawViewHierarchyInRect failed&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;ios7-以前截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;iOS7 以前截图&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;- (UIImage *)captureCurrentView:(UIView *)view {
    CGRect frame = view.frame;
    UIGraphicsBeginImageContext(frame.size);
    CGContextRef contextRef = UIGraphicsGetCurrentContext();
    [view.layer renderInContext:contextRef];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
    
    // 获取指定区域的截图
    CGImageRef imageRef = image.CGImage;
    CGRect rect = CGRectMake(0, 0, 300, 300);  //设置指定区域
    CGImageRef editImageRef = CGImageCreateWithImageInRect(imageRef, rect);
    UIImage *editImage = [UIImage alloc] initWithCGImage:editImageRef];
    return editImage;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-uiscorllview-截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;2. UIScorllView 截图&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- (void)screenShot{  
        UIImage *image = nil;         
        UIGraphicsBeginImageContext(_scrollView.contentSize);  
      
        {  
            CGPoint savedContentOffset = _scrollView.contentOffset;  
            CGRect savedFrame = _scrollView.frame;  
            _scrollView.contentOffset = CGPointZero;  
      
            _scrollView.frame = CGRectMake(0, 0, m_scrollView.contentSize.width, m_scrollView.contentSize.height);        
            [_scrollView.layer renderInContext: UIGraphicsGetCurrentContext()];  
      
            image = UIGraphicsGetImageFromCurrentImageContext();       
      
            _scrollView.contentOffset = savedContentOffset;  
            _scrollView.frame = savedFrame;  
        }  
        UIGraphicsEndImageContext();      
      
        if (image != nil) {  
            NSLog(@&amp;quot;success snapshot!&amp;quot;);  
        }  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-截图后拼图:793ee16878053e99cf22e48f2d18d892&#34;&gt;3. 截图后拼图&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;-(void)combinImg:(id)sender
{
    if (self.imgArr.count &amp;lt;=0 ) {
        return;
    }
    NSString *rootPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
 CGFloat tatolHight = self.tableView.contentSize.height +  self.tableView.contentInset.top;
UIGraphicsBeginImageContextWithOptions(CGSizeMake(self.tableView.frame.size.width, tatolHight), NO, 1);    
    CGFloat orgy = 0;
    for(int i = 0; i &amp;lt; self.imgArr.count;i++)
    {
        UIImage *image = (UIImage*)self.imgArr[i];
        [image drawInRect:CGRectMake(0, orgy,image.size.width, image.size.height)];
        orgy += image.size.height;
    }
    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.tableView.frame.size.height )];
    scrollView.contentSize = CGSizeMake(self.view.bounds.size.width, self.tableView.contentSize.height + 64);
    scrollView.backgroundColor = [UIColor brownColor];
    [self.view addSubview:scrollView];
    
    UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 64, scrollView.frame.size.width, self.tableView.contentSize.height)];
    imgView.backgroundColor = [UIColor purpleColor];
    imgView.image = img;
    [scrollView addSubview:imgView];
    
    //写到文件中可打开文件查看
    NSString *path = [rootPath stringByAppendingPathComponent:@&amp;quot;combin.png&amp;quot;];
    NSData *imgData = UIImagePNGRepresentation(img);
    [imgData writeToFile:path atomically:YES];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>多线程 NSOperation</title>
      <link>http://felixmlians.github.io/2014/11/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B-nsoperation/</link>
      <pubDate>Mon, 17 Nov 2014 14:01:09 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/11/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B-nsoperation/</guid>
      <description>

&lt;h4 id=&#34;nsoperation介绍:222d30bac2b83aad43e4b91c3497980d&#34;&gt;NSOperation介绍&lt;/h4&gt;

&lt;p&gt;NSOperation是一个抽象的基类，表示一个独立的计算单元，可以为子类提供有用且线程安全的建立状态，优先级，依赖和取消等操作。系统已经给我们封装了NSBlockOperation和NSInvocationOperation这两个实体类。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用NSOperation处理多线程时，就是将“操作”添加到队列中。&lt;/li&gt;
&lt;li&gt;NSOperation是一个抽象类，不能直接使用(方法没有实现)，约束子类都具有共同的属性和方法。&lt;/li&gt;
&lt;li&gt;NSOperation的子类：NSInvocationOperation、NSBlockOperation、自定义NSOperation。&lt;/li&gt;
&lt;li&gt;通过NSOperationQueue可以创建并发队列，获取主队列，获取当前队列。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;nsoperation定义:222d30bac2b83aad43e4b91c3497980d&#34;&gt;NSOperation定义&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- (void)start;
- (void)main;

@property (readonly, getter=isCancelled) BOOL cancelled;
- (void)cancel;

@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &#39;asynchronous&#39; below
@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);
@property (readonly, getter=isReady) BOOL ready;

- (void)addDependency:(NSOperation *)op;
- (void)removeDependency:(NSOperation *)op;

@property (readonly, copy) NSArray *dependencies;

typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};

@property NSOperationQueuePriority queuePriority;

@property (copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);

- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);

@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);

@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);

@property (copy) NSString *name NS_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;状态:222d30bac2b83aad43e4b91c3497980d&#34;&gt;状态&lt;/h5&gt;

&lt;p&gt;NSOperation提供了&lt;code&gt;ready cancelled executing finished&lt;/code&gt;这几个状态变化，我们的开发也是必须处理自己关心的其中的状态。这些状态都是基于keypath的KVO通知决定，所以在你手动改变自己关心的状态时，请别忘了手动发送通知。这里面每个属性都是相互独立的，同时只可能有一个状态是YES。finished这个状态在操作完成后请及时设置为YES，因为NSOperationQueue所管理的队列中，只有isFinished为YES时才将其移除队列，这点在内存管理和避免死锁很关键。&lt;/p&gt;

&lt;h5 id=&#34;依赖:222d30bac2b83aad43e4b91c3497980d&#34;&gt;依赖&lt;/h5&gt;

&lt;p&gt;NSOperation中我们可以为操作分解为若干个小的任务，通过添加他们之间的依赖关系进行操作，我们可以直接调用 &lt;code&gt;- (void)addDependency:(NSOperation*)op;&lt;/code&gt; 这个方法添加依赖.依赖关系可以跨操作队列，操作不再同一个队列中，依赖关系也是存在的。&lt;/p&gt;

&lt;h5 id=&#34;执行:222d30bac2b83aad43e4b91c3497980d&#34;&gt;执行&lt;/h5&gt;

&lt;p&gt;执行一个operation有两种方法，第一种是自己手动的调用start这个方法，这种方法调用会在当前调用的线程进行同步执行，所以在主线程里面自己一定要小心的调用，不然就会把主线程给卡死。第二种是将operation添加到operationQueue中去，这个也是我们用得最多的也是提倡的方法。NSOperationQueue会在我们添加进去operation的时候尽快进行执行。当然如果 &lt;code&gt;NSOperationQueue的maxConcurrentOperationCount&lt;/code&gt; 如果设置为1的话，进相当于FIFO了。&lt;/p&gt;

&lt;h4 id=&#34;gcd和nsoperation的对比:222d30bac2b83aad43e4b91c3497980d&#34;&gt;GCD和NSOperation的对比&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;GCD&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;GCD是iOS4.0推出的，主要针对多核CPU做了优化，是C语言的技术。 

GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数。

GCD提供给了一些NSOperation不具备的功能：①一次性执行；②延迟执行；③调度组。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;NSOperation&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;NSOperation是iOS2.0推出的，iOS4.0之后重写了NSOperation。

NSOperation将操作(异步的任务)添加到队列(并发队列)，就会执行指定操作的函数。

NSOperation里提供的方便的操作：①最大并发数；②队列的暂停/继续；③取消所有的操作；④指定操作之间的依赖关系(GCD可以用同步实现)。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SQLite（简介）</title>
      <link>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 22 Oct 2014 17:27:18 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;p&gt;SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。
就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。&lt;/p&gt;

&lt;p&gt;所有教程参考地址： &lt;a href=&#34;http://www.runoob.com/sqlite/sqlite-intro.html&#34;&gt;http://www.runoob.com/sqlite/sqlite-intro.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：&lt;/p&gt;

&lt;h4 id=&#34;ddl-数据定义语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DDL - 数据定义语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;CREATE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一个新的表，一个表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ALTE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改数据库中的某个已有的数据库对象，比如一个表。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DROP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除整个表，或者表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dml-数据操作语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DML - 数据操作语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;INSERT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一条记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;UPDAT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DELETE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dql-数据查询语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DQL - 数据查询语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SELECT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从一个或多个表中检索某些记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;在-mac-os-x-上安装-sqlite:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;在 Mac OS X 上安装 SQLite&lt;/h4&gt;

&lt;p&gt;最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请访问 SQLite 下载页面，从源代码区下载 sqlite-autoconf-*.tar.gz。&lt;/li&gt;
&lt;li&gt;步骤如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	$tar xvfz sqlite-autoconf-3071502.tar.gz
	$cd sqlite-autoconf-3071502
	$./configure --prefix=/usr/local
	$make
	$make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sqlite3
SQLite version 3.7.15.2 2013-01-09 11:53:05
Enter &amp;quot;.help&amp;quot; for instructions
Enter SQL statements terminated with a &amp;quot;;&amp;quot;
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令-1:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;获取可用的点命令的清单，可以在任何时候输入 &amp;ldquo;.help&amp;rdquo;。&lt;code&gt;sqlite&amp;gt;.help&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 .show 命令，来查看 SQLite 命令提示符的默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.show
     echo: off
  explain: off
  headers: off
     mode: column
nullvalue: &amp;quot;&amp;quot;
   output: stdout
separator: &amp;quot;|&amp;quot;
    width:
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;确保 sqlite&amp;gt; 提示符与点命令之间没有空格，否则将无法正常工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用下列的点命令来格式化输出为本教程下面所列出的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.header on
sqlite&amp;gt;.mode column
sqlite&amp;gt;.timer on
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面设置将产生如下格式的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID          NAME        AGE         ADDRESS     SALARY
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0
2           Allen       25          Texas       15000.0
3           Teddy       23          Norway      20000.0
4           Mark        25          Rich-Mond   65000.0
5           David       27          Texas       85000.0
6           Kim         22          South-Hall  45000.0
7           James       24          Houston     10000.0
CPU Time: user 0.000000 sys 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主表中保存数据库表的关键信息，并把它命名为 sqlite_master。如要查看表概要，可按如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.schema sqlite_master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将产生如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE sqlite_master (
  type text,
  name text,
  tbl_name text,
  rootpage integer,
  sql text
);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS HTTP Multipart Forms POST(头像图片上传)</title>
      <link>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</link>
      <pubDate>Sat, 13 Sep 2014 12:49:42 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</guid>
      <description>&lt;p&gt;由于iOS无法通过html表单来上传图片，因此想要上传图片，必须实现http请求，而不能像其他语言那样通过html表单的post就能上传。&lt;/p&gt;

&lt;p&gt;上传图片的http post请求的格式是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-type: multipart/form-data, boundary=---------------------------14737809831466499882746641449

---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.jpg&amp;quot;
Content-Type: image/jpeg

... contents of boo,jpg ...
---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
---------------------------14737809831466499882746641449
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行是指定了&lt;code&gt;http post&lt;/code&gt;请求的编码方式为&lt;code&gt;multipart/form-data&lt;/code&gt;（上传文件必须用这个）。
&lt;code&gt;boundary= xxx&lt;/code&gt; 说明了&lt;code&gt;xxx&lt;/code&gt;为分界线。比如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt; 就是一个分界线的意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话声明了请求中的一个字段的名称，如&lt;code&gt;info&lt;/code&gt;  以及字段的值，如&lt;code&gt;Hello Boris!&lt;/code&gt;
这里类似&lt;code&gt;form&lt;/code&gt;表单中的&lt;code&gt;&amp;lt;input name=&amp;quot;info&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;Hello Boris!&amp;quot;/&amp;gt;&lt;/code&gt;
中间的空行是必须的。&lt;/p&gt;

&lt;p&gt;不同的字段之间用分界线分开，分界线需要单独一行，如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分界线的下一行，是下一个字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;content-disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.png&amp;quot;
Content-Type: image/png

... contents of boo.png ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里声明了变量&lt;code&gt;pic&lt;/code&gt;，也就是我们要传的文件，上传文件的时候需要在后边指定&lt;code&gt;file name：filename=&amp;quot;boo.png&amp;quot;&lt;/code&gt;
并且需要在下一行指定文件的格式：&lt;code&gt;Content-Type: image/png&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;... contents of boo.png ...&lt;/code&gt;  这里是&lt;code&gt;boo.png&lt;/code&gt;的二进制内容，如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;89504e47 0d0a1a0a 0000000d 49484452 000000b4 000000b4 08020000 00b2af91 65000020 00494441 5478012c dd79b724 6b7616f6 8c888c88 8c9c8733 55ddb1d5 6a0db486 06218401 ......&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在http post请求的结尾，需要有一个分界线，但是是前后都有&amp;ndash;的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上的这些格式，是http的规范，每个空行，空格都是必须的。&lt;/p&gt;

&lt;p&gt;下边是iOS的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 建立请求对象
NSMutableURLRequest * request = [[NSMutableURLRequest alloc] init];
[request setURL:[NSURL URLWithString:kRequestBaseApi]];

// 请求方式
[request setHTTPMethod:@&amp;quot;POST&amp;quot;];
[request setTimeoutInterval:kCLTimeoutInterval];

// 接口参数
NSString *string = [NSString stringWithFormat:@&amp;quot;{\&amp;quot;action\&amp;quot;:\&amp;quot;saveHeadImg\&amp;quot;,\&amp;quot;uid\&amp;quot;:\&amp;quot;%@\&amp;quot;}&amp;quot;, [ClientState shareInstance].currentUID];

// 头标签，分隔线
NSString *boundary = @&amp;quot;---------------------------14737809831466499882746641449&amp;quot;;
NSString *contentType = [NSString stringWithFormat:@&amp;quot;multipart/form-data; boundary=%@&amp;quot;,boundary];
[request addValue:contentType forHTTPHeaderField: @&amp;quot;Content-Type&amp;quot;];

NSMutableData *body = [NSMutableData data];

// 添加接口参数
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;req\&amp;quot;\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;%@\r\n&amp;quot;,string] dataUsingEncoding:NSUTF8StringEncoding]];

// 添加图片data
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;files\&amp;quot;; filename=\&amp;quot;%@\&amp;quot;\r\n&amp;quot;, fileName]
                  dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Type: image/pjpeg\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[NSData dataWithData:imageData]];

// 添加尾部分隔线
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@--\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[request setHTTPBody:body];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于宏</title>
      <link>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</link>
      <pubDate>Sat, 09 Aug 2014 11:38:21 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</guid>
      <description>

&lt;p&gt;C中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)。对于对象宏来说确实相对简单，但却也不是那么简单的查找替换。对象宏一般用来定义一些常数，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define M_PI    3.14159265358979323846264338327950288
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;关键字表明即将开始定义一个宏，紧接着的&lt;code&gt;M_PI&lt;/code&gt;是宏的名字，空格之后的数字是内容。类似这样的&lt;code&gt;#define X A&lt;/code&gt;的宏是比较简单的，在编译时编译器会在语义分析认定是宏后，将X替换为A，这个过程称为宏的展开。比如对于上面的&lt;code&gt;M_PI&lt;/code&gt;直接使用。&lt;/p&gt;

&lt;p&gt;函数宏顾名思义，就是行为类似函数，可以接受参数的宏。具体来说，在定义的时候，如果我们在宏名字后面跟上一对括号的话，这个宏就变成了函数宏。从最简单的例子开始，比如下面这个函数宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DES(x)  x
NSString *name = @&amp;quot;Macro Rookie&amp;quot;;  
NSLog(@&amp;quot;Hello %@&amp;quot;,DES(name));  
// =&amp;gt; NSLog(@&amp;quot;Hello %@&amp;quot;,name);
//   =&amp;gt; Hello Macro Rookie 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏做的事情是，在编译时如果遇到&lt;code&gt;DES&lt;/code&gt;，并且后面带括号，并且括号中的参数个数与定义的相符，那么就将括号中的参数换到定义的内容里去，然后替换掉原来的内容。 具体到这段代码中，&lt;code&gt;DES&lt;/code&gt;接受了一个&lt;code&gt;name&lt;/code&gt;，然后将整个&lt;code&gt;DES(name)&lt;/code&gt;用&lt;code&gt;name&lt;/code&gt;替换掉。多个参数的宏例如这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PLUS(x,y) (x + y)
printf(&amp;quot;%d&amp;quot;,PLUS(3,2));  
// =&amp;gt; printf(&amp;quot;%d&amp;quot;,3 + 2);
//  =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;因为宏展开其实是编辑器的预处理，因此它可以在更高层级上控制程序源码本身和编译流程。而正是这个特点，赋予了宏很强大的功能和灵活度。但是凡事都有两面性，在获取灵活的背后，是以需要大量时间投入以对各种边界情况进行考虑来作为代价的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#define __NSX_PASTE__(A,B) A##B

#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)

#define __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); \
                                 __typeof__(B) __NSX_PASTE__(__b,L) = (B); \
                                (__NSX_PASTE__(__a,L) &amp;lt; __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); \
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;MIN&lt;/code&gt;一共由三个宏定义组合而成。第一个&lt;code&gt;__NSX_PASTE__&lt;/code&gt;里出现的两个连着的井号&lt;code&gt;##&lt;/code&gt;在宏中是一个特殊符号，它表示将两个参数连接起来这种运算。注意函数宏必须是有意义的运算，因此你不能直接写&lt;code&gt;AB&lt;/code&gt;来连接两个参数，而需要写成例子中的&lt;code&gt;A##B&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来是我们调用的两个参数的&lt;code&gt;MIN&lt;/code&gt;，它做的事是调用了另一个三个参数的宏&lt;code&gt;__NSMIN_IMPL__&lt;/code&gt;，其中前两个参数就是我们的输入，而第三个&lt;code&gt;__COUNTER__&lt;/code&gt;是一个预定义的宏，这个值在编译过程中将从&lt;code&gt;0&lt;/code&gt;开始计数，每次被调用时加&lt;code&gt;1&lt;/code&gt;。因为唯一性，所以很多时候被用来构造独立的变量名称。有了上面的基础，再来看最后的实现宏就很简单了。整体思路和前面的实现和之前的GNUC MIN是一样的，区别在于为变量名&lt;code&gt;__a&lt;/code&gt;和&lt;code&gt;__b&lt;/code&gt;添加了一个计数后缀，这样大大避免了变量名相同而导致问题的可能性。&lt;/p&gt;

&lt;h3 id=&#34;log:88505ded347af25f6a47875a4eb189b9&#34;&gt;Log&lt;/h3&gt;

&lt;p&gt;我们通过宏，可以很简单地完成对NSLog原生行为的改进，优雅，高效。只需要在预编译的pch文件中加上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//A better version of NSLog
#define NSLog(format, ...) do {  \
                              fprintf(stderr, &amp;quot;&amp;lt;%s : %d&amp;gt; %s\n&amp;quot;,   \
                              [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \
                              __LINE__, __func__);\
                              (NSLog)((format), ##__VA_ARGS__);   \
                              fprintf(stderr, &amp;quot;-------\n&amp;quot;);   \
                             } while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是定义部分，第2行的&lt;code&gt;NSLog(format, ...)&lt;/code&gt;。我们看到的是一个函数宏，但是它的参数比较奇怪，第二个参数是&lt;code&gt;...&lt;/code&gt;，在宏定义（其实也包括函数定义）的时候，写为&lt;code&gt;...&lt;/code&gt;的参数被叫做可变参数(variadic)。可变参数的个数不做限定。在这个宏定义中，除了第一个参数format将被单独处理外，接下来输入的参数将作为整体一并看待。回想一下NSLog的用法，我们在使用NSLog时，往往是先给一个format字符串作为第一个参数，然后根据定义的格式在后面的参数里跟上写要输出的变量之类的。这里第一个格式化字符串即对应宏里的format，后面的变量全部映射为&lt;code&gt;...&lt;/code&gt;作为整体处理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__FILE__&lt;/code&gt;返回当前文件的绝对路径，&lt;code&gt;__LINE__&lt;/code&gt;返回展开该宏时在文件中的行数，&lt;code&gt;__func__&lt;/code&gt;是改宏所在scope的函数名称。我们在做Log输出时如果带上这这三个参数，便可以加快解读Log，迅速定位。关于编译器预定义的Log以及它们的一些实现机制，感兴趣的同学可以移步到gcc文档的PreDefine页面和clang的Builtin Macro进行查看。在这里我们将格式化输出的三个参数分别设定为文件名的最后一个部分（因为绝对路径太长很难看），行数，以及方法名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define NSLogRect(rect) NSLog(@&amp;quot;%s x:%.4f, y:%.4f, w:%.4f, h:%.4f&amp;quot;, #rect, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)
#define NSLogSize(size) NSLog(@&amp;quot;%s w:%.4f, h:%.4f&amp;quot;, #size, size.width, size.height)
#define NSLogPoint(point) NSLog(@&amp;quot;%s x:%.4f, y:%.4f&amp;quot;, #point, point.x, point.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;宏:88505ded347af25f6a47875a4eb189b9&#34;&gt;宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//获取系统版本  
#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]  
#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion]  

//获取当前语言  
#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])  

//判断是否 Retina屏、设备是否%fhone 5、是否是iPad  
#define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)  
#define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO)  
#define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)     

// rgb颜色转换（16进制-&amp;gt;10进制）  
#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16))/255.0 green:((float)((rgbValue &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8))/255.0 blue:((float)(rgbValue &amp;amp; 0xFF))/255.0 alpha:1.0]  

//带有RGBA的颜色设置  
#define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]  

// 获取RGB颜色  
#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]  
#define RGB(r,g,b) RGBA(r,g,b,1.0f)

  //由角度获取弧度 有弧度获取角度  
#define degreesToRadian(x) (M_PI * (x) / 180.0)  
#define radianToDegrees(radian) (radian*180.0)/(M_PI)  

#define DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, onceBlock);

DISPATCH_ONCE_BLOCK(^{
//code
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>