<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Felix&#39;s  Space</title>
    <link>http://felixmlians.github.io/post/</link>
    <description>Recent content in Posts on Felix&#39;s  Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012 - 2018, Felix M Lians; all rights reserved.</copyright>
    <lastBuildDate>Thu, 24 Sep 2015 22:20:19 +0120</lastBuildDate>
    <atom:link href="http://felixmlians.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>React入门-002</title>
      <link>http://felixmlians.github.io/2015/09/24/react%E5%85%A5%E9%97%A8-002/</link>
      <pubDate>Thu, 24 Sep 2015 22:20:19 +0120</pubDate>
      
      <guid>http://felixmlians.github.io/2015/09/24/react%E5%85%A5%E9%97%A8-002/</guid>
      <description>

&lt;h3 id=&#34;1-proptypes:59590282874bf473b9caec61cb37403d&#34;&gt;1，PropTypes&lt;/h3&gt;

&lt;p&gt;组件的属性可以接受任意值，字符串、对象、函数等等都可以。
组件类的PropTypes属性是用来验证组件实例的属性是否符合要求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyTitle = React.createClass({
  propTypes: {
title: React.PropTypes.string.isRequired,
  },

  render: function() {
 return &amp;lt;h1&amp;gt; {this.props.title} &amp;lt;/h1&amp;gt;;
   }
});

var title = &amp;quot;hello&amp;quot;;

ReactDOM.render(
  &amp;lt;MyTitle title={title} /&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getDefaultProps&lt;/code&gt; 方法可以用来设置组件属性的默认值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyTitle = React.createClass({
  getDefaultProps : function () {
return {
  title : &#39;Hello World&#39;
};
  },

  render: function() {
 return &amp;lt;h1&amp;gt; {this.props.title} &amp;lt;/h1&amp;gt;;
   }
});

ReactDOM.render(
  &amp;lt;MyTitle /&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-获取真实的dom节点:59590282874bf473b9caec61cb37403d&#34;&gt;2，获取真实的DOM节点&lt;/h3&gt;

&lt;p&gt;组件并不是真实的 &lt;code&gt;DOM&lt;/code&gt; 节点，而是存在于内存之中的一种数据结构，叫做&lt;code&gt;虚拟 DOM （virtual DOM）&lt;/code&gt;。只有当它插入文档以后，才会变成真实的 &lt;code&gt;DOM&lt;/code&gt; 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 &lt;code&gt;DOM diff&lt;/code&gt; ，它可以极大提高网页的性能表现。
但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 &lt;code&gt;ref&lt;/code&gt; 属性:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyComponent = React.createClass({
  handleClick: function() {
this.refs.myTextInput.focus();
  },
  render: function() {
return (
  &amp;lt;div&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; ref=&amp;quot;myTextInput&amp;quot; /&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Focus the text input&amp;quot; onClick={this.handleClick} /&amp;gt;
  &amp;lt;/div&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;MyComponent /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组件 &lt;code&gt;MyComponent&lt;/code&gt; 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 &lt;code&gt;DOM&lt;/code&gt; 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 &lt;code&gt;ref&lt;/code&gt; 属性，然后 &lt;code&gt;this.refs.[refName]&lt;/code&gt; 就会返回这个真实的 &lt;code&gt;DOM&lt;/code&gt; 节点。
需要注意的是，由于 &lt;code&gt;this.refs.[refName]&lt;/code&gt; 属性获取的是真实 &lt;code&gt;DOM&lt;/code&gt; ，所以必须等到虚拟 &lt;code&gt;DOM&lt;/code&gt; 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 &lt;code&gt;Clic&lt;/code&gt;k 事件的回调函数，确保了只有等到真实 &lt;code&gt;DOM&lt;/code&gt; 发生 &lt;code&gt;Click&lt;/code&gt; 事件之后，才会读取 &lt;code&gt;this.refs.[refName]&lt;/code&gt; 属性。
React 组件支持很多事件，除了 &lt;code&gt;Click&lt;/code&gt; 事件以外，还有 &lt;code&gt;KeyDown&lt;/code&gt; 、&lt;code&gt;Copy&lt;/code&gt;、&lt;code&gt;Scroll&lt;/code&gt; 等;&lt;/p&gt;

&lt;h3 id=&#34;3-this-state:59590282874bf473b9caec61cb37403d&#34;&gt;3，this.state&lt;/h3&gt;

&lt;p&gt;React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var LikeButton = React.createClass({
  getInitialState: function() {
return {liked: false};
  },
  handleClick: function(event) {
this.setState({liked: !this.state.liked});
  },
  render: function() {
var text = this.state.liked ? &#39;like&#39; : &#39;haven\&#39;t liked&#39;;
return (
  &amp;lt;p onClick={this.handleClick}&amp;gt;
You {text} this. Click to toggle.
  &amp;lt;/p&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;LikeButton /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个 LikeButton 组件，它的 &lt;code&gt;getInitialState&lt;/code&gt; 方法用于定义初始状态，也就是一个对象，这个对象可以通过 &lt;code&gt;this.state&lt;/code&gt; 属性读取。当用户点击组件，导致状态变化，&lt;code&gt;this.setState&lt;/code&gt; 方法就修改状态值，每次修改以后，自动调用 &lt;code&gt;this.render&lt;/code&gt; 方法，再次渲染组件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this.props&lt;/code&gt; 表示那些一旦定义，就不再改变的特性，而 &lt;code&gt;this.state&lt;/code&gt; 是会随着用户互动而产生变化的特性;&lt;/p&gt;

&lt;h3 id=&#34;4-表单:59590282874bf473b9caec61cb37403d&#34;&gt;4, 表单&lt;/h3&gt;

&lt;p&gt;用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Input = React.createClass({
  getInitialState: function() {
return {value: &#39;Hello!&#39;};
  },
  handleChange: function(event) {
this.setState({value: event.target.value});
  },
  render: function () {
var value = this.state.value;
return (
  &amp;lt;div&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; value={value} onChange={this.handleChange} /&amp;gt;
&amp;lt;p&amp;gt;{value}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
);
  }
});

ReactDOM.render(&amp;lt;Input/&amp;gt;, document.body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文本输入框的值，不能用 this.props.value 读取，而要定义一个 &lt;code&gt;onChange&lt;/code&gt; 事件的回调函数，通过 &lt;code&gt;event.target.value&lt;/code&gt; 读取用户输入的值。&lt;code&gt;textarea&lt;/code&gt; 元素、&lt;code&gt;select&lt;/code&gt;元素、&lt;code&gt;radio&lt;/code&gt;元素都属于这种情况;&lt;/p&gt;

&lt;h3 id=&#34;5-组件的生命周期:59590282874bf473b9caec61cb37403d&#34;&gt;5，组件的生命周期&lt;/h3&gt;

&lt;p&gt;组件的生命周期分成三个状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Mounting：已插入真实 DOM
* Updating：正在被重新渲染
* Unmounting：已移出真实 DOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- componentWillMount()
- componentDidMount()
- componentWillUpdate(object nextProps, object nextState)
- componentDidUpdate(object prevProps, object prevState)
- componentWillUnmount()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，React 还提供两种特殊状态的处理函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用
- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Hello = React.createClass({
  getInitialState: function () {
return {
  opacity: 1.0
};
  },

  componentDidMount: function () {
this.timer = setInterval(function () {
  var opacity = this.state.opacity;
  opacity -= .05;
  if (opacity &amp;lt; 0.1) {
opacity = 1.0;
  }
  this.setState({
opacity: opacity
  });
}.bind(this), 100);
  },

  render: function () {
return (
  &amp;lt;div style={{opacity: this.state.opacity}}&amp;gt;
Hello {this.props.name}
  &amp;lt;/div&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;Hello name=&amp;quot;world&amp;quot;/&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组件的style属性的设置方式，这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React入门-001</title>
      <link>http://felixmlians.github.io/2015/09/09/react%E5%85%A5%E9%97%A8-001/</link>
      <pubDate>Wed, 09 Sep 2015 22:09:30 +0900</pubDate>
      
      <guid>http://felixmlians.github.io/2015/09/09/react%E5%85%A5%E9%97%A8-001/</guid>
      <description>

&lt;p&gt;鉴于iOS行情的不好，而且越来越多的公司要求web app和hybrid app的开发。最近发觉React非常的热门，看上去充满希望，当然应该好好学一下。从技术角度，可以满足好奇心，提高技术水平；从职业角度，有利于求职和晋升，有利于参与潜力大的项目。&lt;/p&gt;

&lt;p&gt;于是在github上下载了入门的React Demo,开始入门学习！&lt;/p&gt;

&lt;p&gt;其中React地址 &lt;a href=&#34;https://github.com/facebook/react&#34;&gt;https://github.com/facebook/react&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;React Demo 地址：&lt;a href=&#34;https://github.com/ruanyf/react-demos&#34;&gt;https://github.com/ruanyf/react-demos&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;1-html模板:c427717cf2c20ae79dea8b34898d617a&#34;&gt;1，HTML模板&lt;/h2&gt;

&lt;p&gt;React的网页源码，结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
&amp;lt;script src=&amp;quot;../build/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;../build/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;../build/browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;
  // ** Our code goes here! **
&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最后一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签的 &lt;code&gt;type&lt;/code&gt; 属性为 &lt;code&gt;text/babel&lt;/code&gt; 。这是因为 &lt;code&gt;React&lt;/code&gt; 独有的 &lt;code&gt;JSX&lt;/code&gt; 语法，跟 &lt;code&gt;JavaScript&lt;/code&gt; 不兼容。凡是使用 &lt;code&gt;JSX&lt;/code&gt; 的地方，都要加上 &lt;code&gt;type=&amp;quot;text/babel&amp;quot;&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上面代码一共用了三个库：&lt;code&gt;react.js&lt;/code&gt; 、&lt;code&gt;react-dom.js&lt;/code&gt; 和 &lt;code&gt;Browser.js&lt;/code&gt; ，它们必须首先加载。其中，&lt;code&gt;react.js&lt;/code&gt; 是&lt;code&gt;React&lt;/code&gt; 的核心库，&lt;code&gt;react-dom.js&lt;/code&gt; 是提供与 &lt;code&gt;DOM&lt;/code&gt; 相关的功能，&lt;code&gt;Browser.js&lt;/code&gt; 的作用是将 &lt;code&gt;JSX&lt;/code&gt; 语法转为 &lt;code&gt;JavaScript&lt;/code&gt; 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ babel src --out-dir build&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。&lt;/p&gt;

&lt;h2 id=&#34;2-reactdom-render:c427717cf2c20ae79dea8b34898d617a&#34;&gt;2，ReactDOM.render()&lt;/h2&gt;

&lt;p&gt;ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ReactDOM.render(
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码将一个 h1 标题，插入 example 节点;&lt;/p&gt;

&lt;h2 id=&#34;3-jsx-语法:c427717cf2c20ae79dea8b34898d617a&#34;&gt;3，JSX 语法&lt;/h2&gt;

&lt;p&gt;HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写:&lt;/p&gt;

&lt;p&gt;var names = [&amp;lsquo;Alice&amp;rsquo;, &amp;lsquo;Emily&amp;rsquo;, &amp;lsquo;Kate&amp;rsquo;];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ReactDOM.render(
  &amp;lt;div&amp;gt;
  {
names.map(function (name) {
  return &amp;lt;div&amp;gt;Hello, {name}!&amp;lt;/div&amp;gt;
})
  }
  &amp;lt;/div&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSX 的基本语法规则：遇到 &lt;code&gt;HTML&lt;/code&gt; 标签（以&lt;code&gt;&amp;lt;&lt;/code&gt; 开头），就用 &lt;code&gt;HTML&lt;/code&gt; 规则解析；遇到代码块（以&lt;code&gt;{&lt;/code&gt; 开头），就用 &lt;code&gt;JavaScript&lt;/code&gt; 规则解析。&lt;/p&gt;

&lt;p&gt;JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [
  &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;,
  &amp;lt;h2&amp;gt;React is awesome&amp;lt;/h2&amp;gt;,
];
ReactDOM.render(
  &amp;lt;div&amp;gt;{arr}&amp;lt;/div&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-组件:c427717cf2c20ae79dea8b34898d617a&#34;&gt;4, 组件&lt;/h2&gt;

&lt;p&gt;React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var HelloMessage = React.createClass({
  render: function() {
return &amp;lt;h1&amp;gt;Hello {this.props.name}&amp;lt;/h1&amp;gt;;
  }
});

ReactDOM.render(
  &amp;lt;HelloMessage name=&amp;quot;John&amp;quot; /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量 &lt;code&gt;HelloMessage&lt;/code&gt; 就是一个组件类。模板插入 &lt;code&gt;&amp;lt;HelloMessage /&amp;gt;&lt;/code&gt; 时，会自动生成 &lt;code&gt;HelloMessage&lt;/code&gt; 的一个实例（下文的&amp;rdquo;组件&amp;rdquo;都指组件类的实例）。所有组件类都必须有自己的 &lt;code&gt;render&lt;/code&gt; 方法，用于输出组件。
注意，组件类的第一个字母必须&lt;strong&gt;大写&lt;/strong&gt;，否则会报错，比如&lt;code&gt;HelloMessage&lt;/code&gt;不能写成&lt;code&gt;helloMessage&lt;/code&gt;。另外，组件类只能包含一个*顶层标签*，否则也会报错。&lt;/p&gt;

&lt;p&gt;组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;code&gt;&amp;lt;HelloMessage name=&amp;quot;John&amp;quot;&amp;gt;&lt;/code&gt; ，就是 &lt;code&gt;HelloMessage&lt;/code&gt; 组件加入一个 &lt;code&gt;name&lt;/code&gt; 属性，值为 &lt;code&gt;John&lt;/code&gt;。组件的属性可以在组件类的 &lt;code&gt;this.props&lt;/code&gt; 对象上获取。&lt;/p&gt;

&lt;p&gt;添加组件属性，有一个地方需要注意，就是 class 属性需要写成 &lt;code&gt;className&lt;/code&gt; ，for 属性需要写成 &lt;code&gt;htmlFor&lt;/code&gt; ，这是因为 class 和 for 是 JavaScript 的保留字。&lt;/p&gt;

&lt;h2 id=&#34;5-this-props-children:c427717cf2c20ae79dea8b34898d617a&#34;&gt;5，this.props.children&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;this.props&lt;/code&gt; 对象的属性与组件的属性一一对应，但是有一个例外，就是 &lt;code&gt;this.props.children&lt;/code&gt; 属性。它表示组件的所有子节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var NotesList = React.createClass({
  render: function() {
return (
  &amp;lt;ol&amp;gt;
  {
React.Children.map(this.props.children, function (child) {
  return &amp;lt;li&amp;gt;{child}&amp;lt;/li&amp;gt;;
})
  }
  &amp;lt;/ol&amp;gt;
);
  }
});

ReactDOM.render(
  &amp;lt;NotesList&amp;gt;
&amp;lt;span&amp;gt;hello&amp;lt;/span&amp;gt;
&amp;lt;span&amp;gt;world&amp;lt;/span&amp;gt;
  &amp;lt;/NotesList&amp;gt;,
  document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的 &lt;code&gt;NoteList&lt;/code&gt; 组件有两个 &lt;code&gt;span&lt;/code&gt; 子节点，它们都可以通过 &lt;code&gt;this.props.children&lt;/code&gt; 读取；&lt;/p&gt;

&lt;p&gt;这里需要注意， &lt;code&gt;this.props.children&lt;/code&gt; 的值有三种可能：如果当前组件没有子节点，它就是 &lt;code&gt;undefined&lt;/code&gt; ;如果有一个子节点，数据类型是 &lt;code&gt;object&lt;/code&gt; ；如果有多个子节点，数据类型就是 &lt;code&gt;array&lt;/code&gt; 。所以，处理 &lt;code&gt;this.props.children&lt;/code&gt; 的时候要小心。
React 提供一个工具方法 &lt;code&gt;React.Children&lt;/code&gt; 来处理 &lt;code&gt;this.props.children&lt;/code&gt; 。我们可以用 &lt;code&gt;React.Children.map&lt;/code&gt; 来遍历子节点，而不用担心 &lt;code&gt;this.props.children&lt;/code&gt; 的数据类型是 &lt;code&gt;undefined&lt;/code&gt; 还是 &lt;code&gt;object&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS 多线程锁</title>
      <link>http://felixmlians.github.io/2015/08/27/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</link>
      <pubDate>Thu, 27 Aug 2015 17:35:29 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/08/27/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</guid>
      <description>

&lt;h4 id=&#34;dispatch-semaphore:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;dispatch_semaphore&lt;/h4&gt;

&lt;p&gt;信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），直至计数器大于零，然后线程会减少这个计数。&lt;/p&gt;

&lt;p&gt;在GCD中有三个函数是semaphore的操作，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dispatch_semaphore_create　　　创建一个semaphore&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_signal　　　发送一个信号&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_wait　　　　等待信号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;是发送一个信号，自然会让信号总量加1，&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_t group = dispatch_group_create();   
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);   
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   
    for (int i = 0; i &amp;lt; 100; i++)   
    {   
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   
        dispatch_group_async(group, queue, ^{   
            NSLog(@&amp;quot;%i&amp;quot;,i);   
            sleep(2);   
            dispatch_semaphore_signal(semaphore);   
        });   
    }   
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);   
    dispatch_release(group);   
    dispatch_release(semaphore);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码创建了一个初使值为10的semaphore，每一次for循环都会创建一个新的线程，线程结束的时候会发送一个信号，线程创建之前会信号等待，所以当同时创建了10个线程之后，for循环就会阻塞，等待有线程结束之后会增加一个信号才继续执行，如此就形成了对并发的控制，如上就是一个并发数为10的一个线程队列。&lt;/p&gt;

&lt;h4 id=&#34;pthread-mutex-t:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;pthread_mutex_t&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_NORMAL，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_ERRORCHECK，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型是 PTHREAD_MUTEX_DEFAULT，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;amp;mutex, NULL);

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;amp;mutex);
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;amp;mutex);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;synchronized:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;@synchronized&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nslock:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];
NSLock *lock = [[NSLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;

&lt;h4 id=&#34;nsrecursivelock:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSRecursiveLock&lt;/h4&gt;

&lt;p&gt;NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    static void (^RecursiveMethod)(int);
 
    RecursiveMethod = ^(int value) {
 
        [lock lock];
        if (value &amp;gt; 0) {
 
            NSLog(@&amp;quot;value = %d&amp;quot;, value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };
 
    RecursiveMethod(5);
});
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    sleep(2);
    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];
    if (flag) {
        NSLog(@&amp;quot;lock before date&amp;quot;);
 
        [lock unlock];
    } else {
        NSLog(@&amp;quot;fail to lock before date&amp;quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSRecursiveLock除了实现NSLocking协议的方法外，还提供了两个方法，分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在给定的时间之前去尝试请求一个锁
- (BOOL)lockBeforeDate:(NSDate *)limit
 
// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功
- (BOOL)tryLock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，NSRecursiveLock还声明了一个name属性，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property(copy) NSString *name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用这个字符串来标识一个锁。Cocoa也会使用这个name作为错误描述信息的一部分。&lt;/p&gt;

&lt;h4 id=&#34;nscondition:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSCondition&lt;/h4&gt;

&lt;p&gt;使用NSCondition，实现多线程的同步，即，可实现生产者消费者问题。&lt;/p&gt;

&lt;p&gt;基本思路是，首先要创建公用的NSCondition实例。然后：&lt;/p&gt;

&lt;p&gt;消费者取得锁，取产品，如果没有，则wait，这时会释放锁，直到有线程唤醒它去消费产品；&lt;/p&gt;

&lt;p&gt;生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)conditionTest:(id)sender
{
    NSLog(@&amp;quot;begin condition works!&amp;quot;);
    products = [[NSMutableArray alloc] init];
    condition = [[NSCondition alloc] init];
     
    [NSThread detachNewThreadSelector:@selector(createProducter) toTarget:self withObject:nil];
    [NSThread detachNewThreadSelector:@selector(createConsumenr) toTarget:self withObject:nil];
}
 
- (void)createConsumenr
{
    [condition lock];
    while ([products count] == 0) {
        NSLog(@&amp;quot;wait for products&amp;quot;);
        [condition wait];
    }
    [products removeObjectAtIndex:0];
    NSLog(@&amp;quot;comsume a product&amp;quot;);
    [condition unlock];
}
 
- (void)createProducter
{
    [condition lock];
    [products addObject:[[NSObject alloc] init]];
    NSLog(@&amp;quot;produce a product&amp;quot;);
    [condition signal];
    [condition unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsconditionlock:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSConditionLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
NSConditionLock *theLock = [[NSConditionLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    for (int i=0;i&amp;lt;=2;i++)
    {
        [theLock lock];
        NSLog(@&amp;quot;thread1:%d&amp;quot;,i);
        sleep(2);
        [theLock unlockWithCondition:i];
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [theLock lockWhenCondition:2];
    NSLog(@&amp;quot;thread2&amp;quot;);
    [theLock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsdistributedlock-分布式锁:21f28a9b1cab32cb5f6a7caf9e0a2884&#34;&gt;NSDistributedLock 分布式锁&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>编程小助手 - 学习编程的有效工具</title>
      <link>http://felixmlians.github.io/2015/07/23/%E7%BC%96%E7%A8%8B%E5%B0%8F%E5%8A%A9%E6%89%8B---%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%89%E6%95%88%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 23 Jul 2015 10:47:39 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/07/23/%E7%BC%96%E7%A8%8B%E5%B0%8F%E5%8A%A9%E6%89%8B---%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%89%E6%95%88%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;&lt;strong&gt;编程小助手 - 学习编程的有效工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/bian-cheng-xiao-zhu-shou-xue/id1007208297?mt=8&#34;&gt;https://itunes.apple.com/cn/app/bian-cheng-xiao-zhu-shou-xue/id1007208297?mt=8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4+&lt;/p&gt;

&lt;p&gt;Swift语言如今如火如荼，势头一发不可收拾。作为iOS开发者都应该开始学习swift语言，本软件主要针对Swifter们开发入门，基础知识温故知新的小工具。&lt;/p&gt;

&lt;p&gt;无论你是在坐车途中还是在买单排队，所有细小的时间你都可以充分利用起来，学习充电。&lt;/p&gt;

&lt;p&gt;本工具不仅提供了Swift基础语法，还有详尽的进阶指导资源。&lt;/p&gt;

&lt;p&gt;PS:业余制作，巩固复习下swift语法&lt;/p&gt;

&lt;p&gt;个人博客地址： &lt;a href=&#34;http://felixmlians.github.io/&#34;&gt;http://felixmlians.github.io/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IDFA 3选项释义</title>
      <link>http://felixmlians.github.io/2015/06/11/idfa-3%E9%80%89%E9%A1%B9%E9%87%8A%E4%B9%89/</link>
      <pubDate>Thu, 11 Jun 2015 19:39:50 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/06/11/idfa-3%E9%80%89%E9%A1%B9%E9%87%8A%E4%B9%89/</guid>
      <description>&lt;p&gt;Everything has come to its usual state now. Simply upload your binary as you&amp;rsquo;ve been doing this while, and broadly classify IDFA in two categories:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;publisher: You use third-party ad-networks library to display ad. Choose the 1st option in IDFA -&amp;gt; &amp;ldquo;Serve advertisements within the app&amp;rdquo;. You&amp;rsquo;re a publisher since you show ads, but do not perform advertising for your own app.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Advertiser: You use third-party libraries to track conversions for your app, as well as track &amp;lsquo;goals&amp;rsquo; in your app. You directly do not show ads in your app. Choose the 2nd &amp;amp; 3rd option in IDFA -&amp;gt; &amp;ldquo;Attribute this app installation to a previously served ad&amp;rdquo;. AND &amp;ldquo;Attribute an action taken within this app to a previously served advertisement&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mixed: You track conversions for your app, as well as display ads in your app. Choose all three options.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iOS 砸壳，获取头文件，反编译工具 </title>
      <link>http://felixmlians.github.io/2015/05/21/ios-%E7%A0%B8%E5%A3%B3%E8%8E%B7%E5%8F%96%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 21 May 2015 15:25:47 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/05/21/ios-%E7%A0%B8%E5%A3%B3%E8%8E%B7%E5%8F%96%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AppCrackr,dumpdecrypted
下载地址：&lt;a href=&#34;https://github.com/stefanesser/dumpdecrypted/archive/master.zip&#34;&gt;https://github.com/stefanesser/dumpdecrypted/archive/master.zip&lt;/a&gt;进行砸壳。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用class-dump获取头文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Hopper Disassembler   IDA Pro 进行反编译&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iOS NSDateFormatter </title>
      <link>http://felixmlians.github.io/2015/04/06/ios-nsdateformatter/</link>
      <pubDate>Mon, 06 Apr 2015 23:11:23 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/04/06/ios-nsdateformatter/</guid>
      <description>&lt;p&gt;格式化参数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    G: 公元时代，例如AD公元
    yy: 年的后2位,12
    yyyy: 完整年,2012
    MM: 月，显示为1-12
    MMM: 月，显示为英文月份简写,如 Jan
    MMMM: 月，显示为英文月份全称，如 Janualy
    dd: 日，2位数表示，如02
    d: 日，1-2位显示，如 2
    EEE: 简写星期几，如Sun
    EEEE: 全写星期几，如Sunday
    aa: 上下午，AM/PM
    H: 时，24小时制，0-23
    K：时，12小时制，0-11
    m: 分，1-2位
    mm: 分，2位
    s: 秒，1-2位
    ss: 秒，2位
    S: 毫秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用日期组合：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;yyyy-MM-dd HH:mm:ss.SSS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;yyyy-MM-dd HH:mm:ss&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;yyyy-MM-dd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MM dd yyyy&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS 证书以及迁移到新电脑</title>
      <link>http://felixmlians.github.io/2015/03/01/ios-%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</link>
      <pubDate>Sun, 01 Mar 2015 12:15:44 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/03/01/ios-%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;WARNING：Distribution Certification只有配置证书的电脑才可使用，因此即使导出导出Keychain安装到其他电脑上，其他电脑也不可能具有证书的权限。&lt;strong&gt;（新电脑要发布版本需要重新生成证书）&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;1-certification-证书:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;1. Certification(证书)&lt;/h4&gt;

&lt;p&gt;证书是对电脑开发资格的认证，每个开发者帐号有一套，分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer Certification(开发证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装在电脑上提供权限：开发人员通过设备进行真机测试。
可以生成副本供多台电脑安装；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distribution Certification(发布证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装在电脑上提供发布iOS程序的权限：开发人员可以制做测试版和发布版的程序。&lt;/p&gt;

&lt;p&gt;不可生成副本，仅有配置该证书的电脑才可使用；（副本制做介绍在下面Keychain中介绍）&lt;/p&gt;

&lt;h4 id=&#34;2-provisioning-profile-授权文件:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;2. Provisioning Profile(授权文件)&lt;/h4&gt;

&lt;p&gt;授权文件是对设备如iPod Touch、iPad、iPhone的授权，文件内记录的是设备的UDID和程序的App Id，即：使被授权的设备可以安装或调试Bundle identifier与授权文件中记录的App Id对应的程序。&lt;/p&gt;

&lt;p&gt;开发者帐号在创建授权文件时候会选择App Id，（开发者帐号下App Id中添加，单选）和UDID（开发者帐号下Devices中添加最多100个，多选）。&lt;/p&gt;

&lt;p&gt;授权文件分为两种，对应相应的证书使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer Provisioning Profile(开发授权文件)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在装有开发证书或副本的电脑上使用，开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中，即可进行真机测试。&lt;/p&gt;

&lt;p&gt;注意：确保电脑有权限真机调试，即安装了开发证书或副本；在开发工具中程序的Bundle identifier和选中使用的授权文件的App Id要一致；连接调试的设备的UDID在选中的授权文件中有记录。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distribution Provisioning Profile(发布授权文件)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在装有发布证书的电脑上（即配置证书的电脑，只有一台）制做测试版和发布版的程序。&lt;/p&gt;

&lt;p&gt;发布版就是发布到App Store上的程序文件，开发者帐号创建授权文件时选择store选项，选择App Id，无需选择UDID；&lt;/p&gt;

&lt;p&gt;测试版就是在发布之前交给测试人员可同步到设备上的程序文件，开发者帐号创建授权文件时选择AdHoc，选择App Id和UDID；只有选中的UDID对应的设备才可能安装上通过该授权文件制做的程序。&lt;/p&gt;

&lt;h4 id=&#34;3-keychain-开发密钥:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;3. Keychain(开发密钥)&lt;/h4&gt;

&lt;p&gt;安 装证书成功的情况下证书下都会生成Keychain，上面提到的证书副本（导出证书重新命名）就是通过配置证书的电脑导出Keychain（就是.p12 文件）安装到其他机子上，让其他机子得到证书对应的权限。Developer Certification就可以制做副本Keychain分发到其他电脑上安装，使其可以进行真机测试。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;导出私钥和数字证书是为安全保存和能够在多台电脑上进行工作。打开Keychain Access应用选择’KEY’分类。&lt;/li&gt;
&lt;li&gt;右键点击和你iphone开发证书关联的私钥，并在弹出菜单中选择导出选项。&lt;/li&gt;
&lt;li&gt;使用(.p12)保存包含了你个人信息的钥匙。&lt;/li&gt;
&lt;li&gt;你将会被提示创建一个密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在可以通过.p12文件在不同系统之间传输。双击.p12在其他系统上进行安装。输入你在step4输入的密码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>When you are old</title>
      <link>http://felixmlians.github.io/2015/01/01/when-you-are-old/</link>
      <pubDate>Thu, 01 Jan 2015 00:00:36 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/01/01/when-you-are-old/</guid>
      <description>&lt;p&gt;Another year,so many things changed,so many people left,I don&amp;rsquo;t know what to do,but carry on and on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Viva la vida!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        When you are old and grey and full of sleep
　　　　 And nodding by the fire,take down this book
　　　　 And slowly read,and dream of the soft look
　　　　 Your eyes had once, and of their shadows deep;
　　　　
　　　　 How many loved your moments of glad grace,
　　　　 And loved your beauty with love false or true,
　　　　 But one man loved the pilgrim soul in you,
　　　　 And loved the sorrows of your changing face;
　　　　
　　　　 And bending down beside the glowing bars,
　　　　 Murmur,a little sadly,how love fled
　　　　 And paced upon the mountains overhead
　　　　 And hid his face amid a crowd of stars.
　　
　　(BY William Butler Yeats)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 截屏拼图</title>
      <link>http://felixmlians.github.io/2014/12/22/ios-%E6%88%AA%E5%B1%8F%E6%8B%BC%E5%9B%BE/</link>
      <pubDate>Mon, 22 Dec 2014 11:22:30 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/12/22/ios-%E6%88%AA%E5%B1%8F%E6%8B%BC%E5%9B%BE/</guid>
      <description>

&lt;h4 id=&#34;1-普通界面:793ee16878053e99cf22e48f2d18d892&#34;&gt;1. 普通界面&lt;/h4&gt;

&lt;h5 id=&#34;ios-7-以后截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;ios 7 以后截图&lt;/h5&gt;

&lt;p&gt;ios7中添加了调用 &lt;code&gt;snapshotViewAfterScreenUpdates&lt;/code&gt; 创建一个复合视图的快照。然后返回一个&lt;code&gt;uiview&lt;/code&gt;对象来表示调用视图的整体外观。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Supplying YES for -snapshotViewAfterScreenUpdates: means it needs a trip back to the runloop to actually draw the image. If you supply NO, it will try immediately, but if your view is off screen or otherwise hasn&amp;rsquo;t yet drawn to the screen, the snapshot will be empty.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为返回的是一个view对象,所以,你可以更改它以及它的layer属性.但是呢,你不能够修改它的layer的content属性;如果你试图这么做,将不会有任何效果.如果当前的view还没有渲染,或者这么说吧,因为还没有出现在屏幕上,那么,这个截取的view将不会有能显示的content.&lt;/p&gt;

&lt;p&gt;如果你想要加载一个图形效果,比如blur,请使用这个方法 &lt;code&gt;drawViewHierarchyInRect:afterScreenUpdates:&lt;/code&gt; 来代替.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;quot;UIImage+ImageEffects.h&amp;quot;

- (void)createBlurredSnapshot {
    
    UIGraphicsBeginImageContextWithOptions(self.targetImageView.bounds.size, NO, 0);
    
    BOOL result = [self.sourceImageView drawViewHierarchyInRect:self.targetImageView.bounds afterScreenUpdates:YES];
    
    UIImage *snapshotImage = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    
   if (result)
        self.targetImageView.image = [snapshotImage applyLightEffect];
    else
        NSLog(@&amp;quot;drawViewHierarchyInRect failed&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;ios7-以前截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;iOS7 以前截图&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;- (UIImage *)captureCurrentView:(UIView *)view {
    CGRect frame = view.frame;
    UIGraphicsBeginImageContext(frame.size);
    CGContextRef contextRef = UIGraphicsGetCurrentContext();
    [view.layer renderInContext:contextRef];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
    
    // 获取指定区域的截图
    CGImageRef imageRef = image.CGImage;
    CGRect rect = CGRectMake(0, 0, 300, 300);  //设置指定区域
    CGImageRef editImageRef = CGImageCreateWithImageInRect(imageRef, rect);
    UIImage *editImage = [UIImage alloc] initWithCGImage:editImageRef];
    return editImage;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-uiscorllview-截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;2. UIScorllView 截图&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- (void)screenShot{  
        UIImage *image = nil;         
        UIGraphicsBeginImageContext(_scrollView.contentSize);  
      
        {  
            CGPoint savedContentOffset = _scrollView.contentOffset;  
            CGRect savedFrame = _scrollView.frame;  
            _scrollView.contentOffset = CGPointZero;  
      
            _scrollView.frame = CGRectMake(0, 0, m_scrollView.contentSize.width, m_scrollView.contentSize.height);        
            [_scrollView.layer renderInContext: UIGraphicsGetCurrentContext()];  
      
            image = UIGraphicsGetImageFromCurrentImageContext();       
      
            _scrollView.contentOffset = savedContentOffset;  
            _scrollView.frame = savedFrame;  
        }  
        UIGraphicsEndImageContext();      
      
        if (image != nil) {  
            NSLog(@&amp;quot;success snapshot!&amp;quot;);  
        }  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-截图后拼图:793ee16878053e99cf22e48f2d18d892&#34;&gt;3. 截图后拼图&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;-(void)combinImg:(id)sender
{
    if (self.imgArr.count &amp;lt;=0 ) {
        return;
    }
    NSString *rootPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
 CGFloat tatolHight = self.tableView.contentSize.height +  self.tableView.contentInset.top;
UIGraphicsBeginImageContextWithOptions(CGSizeMake(self.tableView.frame.size.width, tatolHight), NO, 1);    
    CGFloat orgy = 0;
    for(int i = 0; i &amp;lt; self.imgArr.count;i++)
    {
        UIImage *image = (UIImage*)self.imgArr[i];
        [image drawInRect:CGRectMake(0, orgy,image.size.width, image.size.height)];
        orgy += image.size.height;
    }
    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.tableView.frame.size.height )];
    scrollView.contentSize = CGSizeMake(self.view.bounds.size.width, self.tableView.contentSize.height + 64);
    scrollView.backgroundColor = [UIColor brownColor];
    [self.view addSubview:scrollView];
    
    UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 64, scrollView.frame.size.width, self.tableView.contentSize.height)];
    imgView.backgroundColor = [UIColor purpleColor];
    imgView.image = img;
    [scrollView addSubview:imgView];
    
    //写到文件中可打开文件查看
    NSString *path = [rootPath stringByAppendingPathComponent:@&amp;quot;combin.png&amp;quot;];
    NSData *imgData = UIImagePNGRepresentation(img);
    [imgData writeToFile:path atomically:YES];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>多线程 NSOperation</title>
      <link>http://felixmlians.github.io/2014/11/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B-nsoperation/</link>
      <pubDate>Mon, 17 Nov 2014 14:01:09 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/11/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B-nsoperation/</guid>
      <description>

&lt;h4 id=&#34;nsoperation介绍:222d30bac2b83aad43e4b91c3497980d&#34;&gt;NSOperation介绍&lt;/h4&gt;

&lt;p&gt;NSOperation是一个抽象的基类，表示一个独立的计算单元，可以为子类提供有用且线程安全的建立状态，优先级，依赖和取消等操作。系统已经给我们封装了NSBlockOperation和NSInvocationOperation这两个实体类。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用NSOperation处理多线程时，就是将“操作”添加到队列中。&lt;/li&gt;
&lt;li&gt;NSOperation是一个抽象类，不能直接使用(方法没有实现)，约束子类都具有共同的属性和方法。&lt;/li&gt;
&lt;li&gt;NSOperation的子类：NSInvocationOperation、NSBlockOperation、自定义NSOperation。&lt;/li&gt;
&lt;li&gt;通过NSOperationQueue可以创建并发队列，获取主队列，获取当前队列。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;nsoperation定义:222d30bac2b83aad43e4b91c3497980d&#34;&gt;NSOperation定义&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- (void)start;
- (void)main;

@property (readonly, getter=isCancelled) BOOL cancelled;
- (void)cancel;

@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &#39;asynchronous&#39; below
@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);
@property (readonly, getter=isReady) BOOL ready;

- (void)addDependency:(NSOperation *)op;
- (void)removeDependency:(NSOperation *)op;

@property (readonly, copy) NSArray *dependencies;

typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};

@property NSOperationQueuePriority queuePriority;

@property (copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);

- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);

@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);

@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);

@property (copy) NSString *name NS_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;状态:222d30bac2b83aad43e4b91c3497980d&#34;&gt;状态&lt;/h5&gt;

&lt;p&gt;NSOperation提供了&lt;code&gt;ready cancelled executing finished&lt;/code&gt;这几个状态变化，我们的开发也是必须处理自己关心的其中的状态。这些状态都是基于keypath的KVO通知决定，所以在你手动改变自己关心的状态时，请别忘了手动发送通知。这里面每个属性都是相互独立的，同时只可能有一个状态是YES。finished这个状态在操作完成后请及时设置为YES，因为NSOperationQueue所管理的队列中，只有isFinished为YES时才将其移除队列，这点在内存管理和避免死锁很关键。&lt;/p&gt;

&lt;h5 id=&#34;依赖:222d30bac2b83aad43e4b91c3497980d&#34;&gt;依赖&lt;/h5&gt;

&lt;p&gt;NSOperation中我们可以为操作分解为若干个小的任务，通过添加他们之间的依赖关系进行操作，我们可以直接调用 &lt;code&gt;- (void)addDependency:(NSOperation*)op;&lt;/code&gt; 这个方法添加依赖.依赖关系可以跨操作队列，操作不再同一个队列中，依赖关系也是存在的。&lt;/p&gt;

&lt;h5 id=&#34;执行:222d30bac2b83aad43e4b91c3497980d&#34;&gt;执行&lt;/h5&gt;

&lt;p&gt;执行一个operation有两种方法，第一种是自己手动的调用start这个方法，这种方法调用会在当前调用的线程进行同步执行，所以在主线程里面自己一定要小心的调用，不然就会把主线程给卡死。第二种是将operation添加到operationQueue中去，这个也是我们用得最多的也是提倡的方法。NSOperationQueue会在我们添加进去operation的时候尽快进行执行。当然如果 &lt;code&gt;NSOperationQueue的maxConcurrentOperationCount&lt;/code&gt; 如果设置为1的话，进相当于FIFO了。&lt;/p&gt;

&lt;h4 id=&#34;gcd和nsoperation的对比:222d30bac2b83aad43e4b91c3497980d&#34;&gt;GCD和NSOperation的对比&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;GCD&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;GCD是iOS4.0推出的，主要针对多核CPU做了优化，是C语言的技术。 

GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数。

GCD提供给了一些NSOperation不具备的功能：①一次性执行；②延迟执行；③调度组。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;NSOperation&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;NSOperation是iOS2.0推出的，iOS4.0之后重写了NSOperation。

NSOperation将操作(异步的任务)添加到队列(并发队列)，就会执行指定操作的函数。

NSOperation里提供的方便的操作：①最大并发数；②队列的暂停/继续；③取消所有的操作；④指定操作之间的依赖关系(GCD可以用同步实现)。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SQLite（简介）</title>
      <link>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 22 Oct 2014 17:27:18 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;p&gt;SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。
就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。&lt;/p&gt;

&lt;p&gt;所有教程参考地址： &lt;a href=&#34;http://www.runoob.com/sqlite/sqlite-intro.html&#34;&gt;http://www.runoob.com/sqlite/sqlite-intro.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：&lt;/p&gt;

&lt;h4 id=&#34;ddl-数据定义语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DDL - 数据定义语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;CREATE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一个新的表，一个表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ALTE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改数据库中的某个已有的数据库对象，比如一个表。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DROP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除整个表，或者表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dml-数据操作语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DML - 数据操作语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;INSERT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一条记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;UPDAT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DELETE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dql-数据查询语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DQL - 数据查询语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SELECT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从一个或多个表中检索某些记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;在-mac-os-x-上安装-sqlite:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;在 Mac OS X 上安装 SQLite&lt;/h4&gt;

&lt;p&gt;最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请访问 SQLite 下载页面，从源代码区下载 sqlite-autoconf-*.tar.gz。&lt;/li&gt;
&lt;li&gt;步骤如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	$tar xvfz sqlite-autoconf-3071502.tar.gz
	$cd sqlite-autoconf-3071502
	$./configure --prefix=/usr/local
	$make
	$make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sqlite3
SQLite version 3.7.15.2 2013-01-09 11:53:05
Enter &amp;quot;.help&amp;quot; for instructions
Enter SQL statements terminated with a &amp;quot;;&amp;quot;
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令-1:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;获取可用的点命令的清单，可以在任何时候输入 &amp;ldquo;.help&amp;rdquo;。&lt;code&gt;sqlite&amp;gt;.help&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 .show 命令，来查看 SQLite 命令提示符的默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.show
     echo: off
  explain: off
  headers: off
     mode: column
nullvalue: &amp;quot;&amp;quot;
   output: stdout
separator: &amp;quot;|&amp;quot;
    width:
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;确保 sqlite&amp;gt; 提示符与点命令之间没有空格，否则将无法正常工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用下列的点命令来格式化输出为本教程下面所列出的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.header on
sqlite&amp;gt;.mode column
sqlite&amp;gt;.timer on
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面设置将产生如下格式的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID          NAME        AGE         ADDRESS     SALARY
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0
2           Allen       25          Texas       15000.0
3           Teddy       23          Norway      20000.0
4           Mark        25          Rich-Mond   65000.0
5           David       27          Texas       85000.0
6           Kim         22          South-Hall  45000.0
7           James       24          Houston     10000.0
CPU Time: user 0.000000 sys 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主表中保存数据库表的关键信息，并把它命名为 sqlite_master。如要查看表概要，可按如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.schema sqlite_master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将产生如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE sqlite_master (
  type text,
  name text,
  tbl_name text,
  rootpage integer,
  sql text
);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS HTTP Multipart Forms POST(头像图片上传)</title>
      <link>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</link>
      <pubDate>Sat, 13 Sep 2014 12:49:42 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</guid>
      <description>&lt;p&gt;由于iOS无法通过html表单来上传图片，因此想要上传图片，必须实现http请求，而不能像其他语言那样通过html表单的post就能上传。&lt;/p&gt;

&lt;p&gt;上传图片的http post请求的格式是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-type: multipart/form-data, boundary=---------------------------14737809831466499882746641449

---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.jpg&amp;quot;
Content-Type: image/jpeg

... contents of boo,jpg ...
---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
---------------------------14737809831466499882746641449
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行是指定了&lt;code&gt;http post&lt;/code&gt;请求的编码方式为&lt;code&gt;multipart/form-data&lt;/code&gt;（上传文件必须用这个）。
&lt;code&gt;boundary= xxx&lt;/code&gt; 说明了&lt;code&gt;xxx&lt;/code&gt;为分界线。比如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt; 就是一个分界线的意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话声明了请求中的一个字段的名称，如&lt;code&gt;info&lt;/code&gt;  以及字段的值，如&lt;code&gt;Hello Boris!&lt;/code&gt;
这里类似&lt;code&gt;form&lt;/code&gt;表单中的&lt;code&gt;&amp;lt;input name=&amp;quot;info&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;Hello Boris!&amp;quot;/&amp;gt;&lt;/code&gt;
中间的空行是必须的。&lt;/p&gt;

&lt;p&gt;不同的字段之间用分界线分开，分界线需要单独一行，如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分界线的下一行，是下一个字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;content-disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.png&amp;quot;
Content-Type: image/png

... contents of boo.png ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里声明了变量&lt;code&gt;pic&lt;/code&gt;，也就是我们要传的文件，上传文件的时候需要在后边指定&lt;code&gt;file name：filename=&amp;quot;boo.png&amp;quot;&lt;/code&gt;
并且需要在下一行指定文件的格式：&lt;code&gt;Content-Type: image/png&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;... contents of boo.png ...&lt;/code&gt;  这里是&lt;code&gt;boo.png&lt;/code&gt;的二进制内容，如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;89504e47 0d0a1a0a 0000000d 49484452 000000b4 000000b4 08020000 00b2af91 65000020 00494441 5478012c dd79b724 6b7616f6 8c888c88 8c9c8733 55ddb1d5 6a0db486 06218401 ......&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在http post请求的结尾，需要有一个分界线，但是是前后都有&amp;ndash;的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上的这些格式，是http的规范，每个空行，空格都是必须的。&lt;/p&gt;

&lt;p&gt;下边是iOS的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 建立请求对象
NSMutableURLRequest * request = [[NSMutableURLRequest alloc] init];
[request setURL:[NSURL URLWithString:kRequestBaseApi]];

// 请求方式
[request setHTTPMethod:@&amp;quot;POST&amp;quot;];
[request setTimeoutInterval:kCLTimeoutInterval];

// 接口参数
NSString *string = [NSString stringWithFormat:@&amp;quot;{\&amp;quot;action\&amp;quot;:\&amp;quot;saveHeadImg\&amp;quot;,\&amp;quot;uid\&amp;quot;:\&amp;quot;%@\&amp;quot;}&amp;quot;, [ClientState shareInstance].currentUID];

// 头标签，分隔线
NSString *boundary = @&amp;quot;---------------------------14737809831466499882746641449&amp;quot;;
NSString *contentType = [NSString stringWithFormat:@&amp;quot;multipart/form-data; boundary=%@&amp;quot;,boundary];
[request addValue:contentType forHTTPHeaderField: @&amp;quot;Content-Type&amp;quot;];

NSMutableData *body = [NSMutableData data];

// 添加接口参数
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;req\&amp;quot;\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;%@\r\n&amp;quot;,string] dataUsingEncoding:NSUTF8StringEncoding]];

// 添加图片data
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;files\&amp;quot;; filename=\&amp;quot;%@\&amp;quot;\r\n&amp;quot;, fileName]
                  dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Type: image/pjpeg\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[NSData dataWithData:imageData]];

// 添加尾部分隔线
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@--\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[request setHTTPBody:body];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于宏</title>
      <link>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</link>
      <pubDate>Sat, 09 Aug 2014 11:38:21 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</guid>
      <description>

&lt;p&gt;C中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)。对于对象宏来说确实相对简单，但却也不是那么简单的查找替换。对象宏一般用来定义一些常数，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define M_PI    3.14159265358979323846264338327950288
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;关键字表明即将开始定义一个宏，紧接着的&lt;code&gt;M_PI&lt;/code&gt;是宏的名字，空格之后的数字是内容。类似这样的&lt;code&gt;#define X A&lt;/code&gt;的宏是比较简单的，在编译时编译器会在语义分析认定是宏后，将X替换为A，这个过程称为宏的展开。比如对于上面的&lt;code&gt;M_PI&lt;/code&gt;直接使用。&lt;/p&gt;

&lt;p&gt;函数宏顾名思义，就是行为类似函数，可以接受参数的宏。具体来说，在定义的时候，如果我们在宏名字后面跟上一对括号的话，这个宏就变成了函数宏。从最简单的例子开始，比如下面这个函数宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DES(x)  x
NSString *name = @&amp;quot;Macro Rookie&amp;quot;;  
NSLog(@&amp;quot;Hello %@&amp;quot;,DES(name));  
// =&amp;gt; NSLog(@&amp;quot;Hello %@&amp;quot;,name);
//   =&amp;gt; Hello Macro Rookie 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏做的事情是，在编译时如果遇到&lt;code&gt;DES&lt;/code&gt;，并且后面带括号，并且括号中的参数个数与定义的相符，那么就将括号中的参数换到定义的内容里去，然后替换掉原来的内容。 具体到这段代码中，&lt;code&gt;DES&lt;/code&gt;接受了一个&lt;code&gt;name&lt;/code&gt;，然后将整个&lt;code&gt;DES(name)&lt;/code&gt;用&lt;code&gt;name&lt;/code&gt;替换掉。多个参数的宏例如这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PLUS(x,y) (x + y)
printf(&amp;quot;%d&amp;quot;,PLUS(3,2));  
// =&amp;gt; printf(&amp;quot;%d&amp;quot;,3 + 2);
//  =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;因为宏展开其实是编辑器的预处理，因此它可以在更高层级上控制程序源码本身和编译流程。而正是这个特点，赋予了宏很强大的功能和灵活度。但是凡事都有两面性，在获取灵活的背后，是以需要大量时间投入以对各种边界情况进行考虑来作为代价的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#define __NSX_PASTE__(A,B) A##B

#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)

#define __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); \
                                 __typeof__(B) __NSX_PASTE__(__b,L) = (B); \
                                (__NSX_PASTE__(__a,L) &amp;lt; __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); \
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;MIN&lt;/code&gt;一共由三个宏定义组合而成。第一个&lt;code&gt;__NSX_PASTE__&lt;/code&gt;里出现的两个连着的井号&lt;code&gt;##&lt;/code&gt;在宏中是一个特殊符号，它表示将两个参数连接起来这种运算。注意函数宏必须是有意义的运算，因此你不能直接写&lt;code&gt;AB&lt;/code&gt;来连接两个参数，而需要写成例子中的&lt;code&gt;A##B&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来是我们调用的两个参数的&lt;code&gt;MIN&lt;/code&gt;，它做的事是调用了另一个三个参数的宏&lt;code&gt;__NSMIN_IMPL__&lt;/code&gt;，其中前两个参数就是我们的输入，而第三个&lt;code&gt;__COUNTER__&lt;/code&gt;是一个预定义的宏，这个值在编译过程中将从&lt;code&gt;0&lt;/code&gt;开始计数，每次被调用时加&lt;code&gt;1&lt;/code&gt;。因为唯一性，所以很多时候被用来构造独立的变量名称。有了上面的基础，再来看最后的实现宏就很简单了。整体思路和前面的实现和之前的GNUC MIN是一样的，区别在于为变量名&lt;code&gt;__a&lt;/code&gt;和&lt;code&gt;__b&lt;/code&gt;添加了一个计数后缀，这样大大避免了变量名相同而导致问题的可能性。&lt;/p&gt;

&lt;h3 id=&#34;log:88505ded347af25f6a47875a4eb189b9&#34;&gt;Log&lt;/h3&gt;

&lt;p&gt;我们通过宏，可以很简单地完成对NSLog原生行为的改进，优雅，高效。只需要在预编译的pch文件中加上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//A better version of NSLog
#define NSLog(format, ...) do {  \
                              fprintf(stderr, &amp;quot;&amp;lt;%s : %d&amp;gt; %s\n&amp;quot;,   \
                              [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \
                              __LINE__, __func__);\
                              (NSLog)((format), ##__VA_ARGS__);   \
                              fprintf(stderr, &amp;quot;-------\n&amp;quot;);   \
                             } while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是定义部分，第2行的&lt;code&gt;NSLog(format, ...)&lt;/code&gt;。我们看到的是一个函数宏，但是它的参数比较奇怪，第二个参数是&lt;code&gt;...&lt;/code&gt;，在宏定义（其实也包括函数定义）的时候，写为&lt;code&gt;...&lt;/code&gt;的参数被叫做可变参数(variadic)。可变参数的个数不做限定。在这个宏定义中，除了第一个参数format将被单独处理外，接下来输入的参数将作为整体一并看待。回想一下NSLog的用法，我们在使用NSLog时，往往是先给一个format字符串作为第一个参数，然后根据定义的格式在后面的参数里跟上写要输出的变量之类的。这里第一个格式化字符串即对应宏里的format，后面的变量全部映射为&lt;code&gt;...&lt;/code&gt;作为整体处理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__FILE__&lt;/code&gt;返回当前文件的绝对路径，&lt;code&gt;__LINE__&lt;/code&gt;返回展开该宏时在文件中的行数，&lt;code&gt;__func__&lt;/code&gt;是改宏所在scope的函数名称。我们在做Log输出时如果带上这这三个参数，便可以加快解读Log，迅速定位。关于编译器预定义的Log以及它们的一些实现机制，感兴趣的同学可以移步到gcc文档的PreDefine页面和clang的Builtin Macro进行查看。在这里我们将格式化输出的三个参数分别设定为文件名的最后一个部分（因为绝对路径太长很难看），行数，以及方法名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define NSLogRect(rect) NSLog(@&amp;quot;%s x:%.4f, y:%.4f, w:%.4f, h:%.4f&amp;quot;, #rect, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)
#define NSLogSize(size) NSLog(@&amp;quot;%s w:%.4f, h:%.4f&amp;quot;, #size, size.width, size.height)
#define NSLogPoint(point) NSLog(@&amp;quot;%s x:%.4f, y:%.4f&amp;quot;, #point, point.x, point.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;宏:88505ded347af25f6a47875a4eb189b9&#34;&gt;宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//获取系统版本  
#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]  
#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion]  

//获取当前语言  
#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])  

//判断是否 Retina屏、设备是否%fhone 5、是否是iPad  
#define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)  
#define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO)  
#define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)     

// rgb颜色转换（16进制-&amp;gt;10进制）  
#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16))/255.0 green:((float)((rgbValue &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8))/255.0 blue:((float)(rgbValue &amp;amp; 0xFF))/255.0 alpha:1.0]  

//带有RGBA的颜色设置  
#define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]  

// 获取RGB颜色  
#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]  
#define RGB(r,g,b) RGBA(r,g,b,1.0f)

  //由角度获取弧度 有弧度获取角度  
#define degreesToRadian(x) (M_PI * (x) / 180.0)  
#define radianToDegrees(radian) (radian*180.0)/(M_PI)  

#define DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, onceBlock);

DISPATCH_ONCE_BLOCK(^{
//code
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于FMDB/SQLite</title>
      <link>http://felixmlians.github.io/2014/07/18/%E5%85%B3%E4%BA%8Efmdb/sqlite/</link>
      <pubDate>Fri, 18 Jul 2014 21:35:38 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/07/18/%E5%85%B3%E4%BA%8Efmdb/sqlite/</guid>
      <description>

&lt;p&gt;到&lt;a href=&#34;https://github.com/ccgus/fmdb&#34;&gt;https://github.com/ccgus/fmdb&lt;/a&gt; 下载源文件，然后直接将fmdb文件夹拖入到你的工程就OK。
当然你需要添加依赖库：libsqlite3.dylib&lt;/p&gt;

&lt;p&gt;拖入源文件，并且添加依赖库以后你就可以使用FMDB了，引用头文件
&lt;code&gt;#import &amp;quot;FMDB.h&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;USAGE&lt;/h2&gt;

&lt;p&gt;在FMDB中主要有三个类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;FMDatabase - 简单的说这个类就是代表了数据库&lt;/li&gt;
&lt;li&gt;FMResultSet - 这个类表示查询操作的结果&lt;/li&gt;
&lt;li&gt;FMDatabaseQueue - 多线程操作的时候你会用到这个类，并且这是线程安全的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;创建数据库:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;创建数据库&lt;/h3&gt;

&lt;p&gt;你需要使用一个path来创建一个本地FMDatabase数据库，这个path有三种类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以使用一个本地的地址来创建这个数据库，这个地址不一定真实存在，如果不存在，那么FMDB会创建这个数据库并返回，存在则直接返回这个数据库。&lt;/li&gt;
&lt;li&gt;一个空字符串@&amp;ldquo;&amp;rdquo;.FMDB会在本地创建一个临时的数据库，当数据库关闭的时候会删除这个数据库。&lt;/li&gt;
&lt;li&gt;NULL.如果你将这个path填的是NULL，那么这个数据被创建在内存中，数据库关闭的时候被销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(更多信息关于临时数据库和在内存中的数据库，你可以阅读这篇文档 &lt;a href=&#34;http://www.sqlite.org/inmemorydb.html&#34;&gt;http://www.sqlite.org/inmemorydb.html&lt;/a&gt; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMDatabase *db = [FMDatabase databaseWithPath:@&amp;quot;/tmp/tmp.db&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;打开数据库:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;打开数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (![db open]) {
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;executing-updates:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Executing Updates&lt;/h3&gt;

&lt;p&gt;所有不是select操作的操作都算update. 包括 CREATE, UPDATE, INSERT, ALTER, COMMIT, BEGIN, DETACH, DELETE, DROP, END, EXPLAIN, VACUUM, and REPLACE ····换句话说也就是如果你的操作不是以SELECT开头的都是update操作.&lt;/p&gt;

&lt;p&gt;update操作返回一个布尔值，YES表示操作成功，NO表示你可以遇到了一些错误.FMDatabase有两个方法 -lastErrorMessage 和 -lastErrorCode，你可以使用这两个方法来查看错误。&lt;/p&gt;

&lt;h3 id=&#34;executing-queries:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Executing Queries&lt;/h3&gt;

&lt;p&gt;SELECT 查询使用 -executeQuery&amp;hellip; 方法.&lt;/p&gt;

&lt;p&gt;查询成功返回 FMResultSet,失败则是返回nil.
同样你可以使用FMDatabase的两个方法 -lastErrorMessage and -lastErrorCode 来查找原因。&lt;/p&gt;

&lt;p&gt;你需要用一个循环来获取到查询到的每一个值。like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMResultSet *s = [db executeQuery:@&amp;quot;SELECT * FROM myTable&amp;quot;];
while ([s next]) {
    //retrieve values for each record
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FMResultSet 有许多类型用来返回不同类型的查询结果的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;intForColumn:
longForColumn:
longLongIntForColumn:
boolForColumn:
doubleForColumn:
stringForColumn:
dateForColumn:
dataForColumn:
dataNoCopyForColumn:
UTF8StringForColumnName:
objectForColumnName:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的每个方法都有对应的 {type}ForColumnIndex: 上面那一溜方法是用例的名字来获取数据，而这个方法则是用数据在查询结果中对应的位置来获取数据.&lt;/p&gt;

&lt;h3 id=&#34;closing:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Closing&lt;/h3&gt;

&lt;p&gt;用完了FMDB记得关闭&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[db close];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;批处理:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;批处理&lt;/h3&gt;

&lt;p&gt;FMDatabase的方法 executeStatements:withResultBlock:可以使用字符串来同时处理多条指令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *sql = @&amp;quot;create table test1 (id integer primary key autoincrement, x text);&amp;quot;
                 &amp;quot;create table test2 (id integer primary key autoincrement, y text);&amp;quot;
                 &amp;quot;create table test3 (id integer primary key autoincrement, z text);&amp;quot;
                 &amp;quot;insert into test1 (x) values (&#39;XXX&#39;);&amp;quot;
                 &amp;quot;insert into test2 (y) values (&#39;YYY&#39;);&amp;quot;
                 &amp;quot;insert into test3 (z) values (&#39;ZZZ&#39;);&amp;quot;;

success = [db executeStatements:sql];

sql = @&amp;quot;select count(*) as count from test1;&amp;quot;
       &amp;quot;select count(*) as count from test2;&amp;quot;
       &amp;quot;select count(*) as count from test3;&amp;quot;;

success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) {
    NSInteger count = [dictionary[@&amp;quot;count&amp;quot;] integerValue];
    XCTAssertEqual(count, 1, @&amp;quot;expected one record for dictionary %@&amp;quot;, dictionary);
    return 0;
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据处理:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;数据处理&lt;/h3&gt;

&lt;p&gt;你必须使用标准的SQLite的标准语法，像下面那样（而不是SQL中那样）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO myTable VALUES (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘？’这个符号表示插入数据的替代符，操作方法会接收参数来替代这个符号 (或者是代表这些参数的，比如说：NSArray, NSDictionary, va_list).&lt;/p&gt;

&lt;p&gt;OC中你可以像下面这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSInteger identifier = 42;
NSString *name = @&amp;quot;Liam O&#39;Flaherty (\&amp;quot;the famous Irish author\&amp;quot;)&amp;quot;;
NSDate *date = [NSDate date];
NSString *comment = nil;

BOOL success = [db executeUpdate:@&amp;quot;INSERT INTO authors (identifier, name, date, comment) VALUES (?, ?, ?, ?)&amp;quot;, @(identifier), name, date, comment ?: [NSNull null]];
if (!success) {
NSLog(@&amp;quot;error = %@&amp;quot;, [db lastErrorMessage]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note:这里需要注意的是，如果是基本数据类型比如说&lt;code&gt;NSInteger&lt;/code&gt;，你需要转化为&lt;code&gt;NSNumber&lt;/code&gt;。
如果是插入nil，那么你不能直接插入nil，而是需要插入&lt;code&gt;[NSNull null]&lt;/code&gt;，像上面那个例子中写的是：&lt;code&gt;comment ?: [NSNull null]&lt;/code&gt;，那么如果commit是nil的话则会插入nil，反之则会插入commit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这种书写方法和上面表达的是同一个意思。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO authors (identifier, name, date, comment) VALUES (:identifier, :name, :date, :comment)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像上面这种写法参数是以冒号开头的，SQLite支持其他字符，但是在字典中key都是以冒号为前缀的，所以你的字典key中不要包含冒号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSDictionary *arguments = @{@&amp;quot;identifier&amp;quot;: @(identifier), @&amp;quot;name&amp;quot;: name, @&amp;quot;date&amp;quot;: date, @&amp;quot;comment&amp;quot;: comment ?: [NSNull null]};
BOOL success = [db executeUpdate:@&amp;quot;INSERT INTO authors (identifier, name, date, comment) VALUES (:identifier, :name, :date, :comment)&amp;quot; withParameterDictionary:arguments];
if (!success) {
NSLog(@&amp;quot;error = %@&amp;quot;, [db lastErrorMessage]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最关键的一点就是：千万不要用NSString的方法比如说 stringWithFormat来手动插入参数，必须要使用Values(?，?)这样的方法，把？当作替代符。&lt;/p&gt;

&lt;h3 id=&#34;fmdatabasequeue-是线程安全的:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;FMDatabaseQueue 是线程安全的&lt;/h3&gt;

&lt;p&gt;不要在多个线程之间使用同一个 FMDatabase对象，最好是每一个线程都有一个独立的 FMDatabase对象，如果你在多线程之间使用同一个对象，那么会有不好的事情发生。
如果你需要在多线程中使用 FMDatabase,那么请使用 FMDatabaseQueue，下面是他的使用方法:&lt;/p&gt;

&lt;p&gt;首先创建你的线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，像这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[queue inDatabase:^(FMDatabase *db) {
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @1];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @2];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @3];

FMResultSet *rs = [db executeQuery:@&amp;quot;select * from foo&amp;quot;];
while ([rs next]) {
    …
}
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An easy way to wrap things up in a transaction can be done like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[queue inTransaction:^(FMDatabase *db, BOOL *rollback) {
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @1];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @2];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @3];

if (whoopsSomethingWrongHappened) {
    *rollback = YES;
    return;
}
// etc…
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @4];
}];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>