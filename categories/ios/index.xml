<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios on Felix&#39;s  Space</title>
    <link>http://felixmlians.github.io/categories/ios/</link>
    <description>Recent content in Ios on Felix&#39;s  Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012 - 2018, Felix M Lians; all rights reserved.</copyright>
    <lastBuildDate>Mon, 17 Nov 2014 14:01:09 +0800</lastBuildDate>
    <atom:link href="http://felixmlians.github.io/categories/ios/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>iOS 多线程锁</title>
      <link>http://felixmlians.github.io/2014/11/17/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</link>
      <pubDate>Mon, 17 Nov 2014 14:01:09 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/11/17/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</guid>
      <description>

&lt;h4 id=&#34;dispatch-semaphore:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;dispatch_semaphore&lt;/h4&gt;

&lt;p&gt;信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），直至计数器大于零，然后线程会减少这个计数。&lt;/p&gt;

&lt;p&gt;在GCD中有三个函数是semaphore的操作，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dispatch_semaphore_create　　　创建一个semaphore&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_signal　　　发送一个信号&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_wait　　　　等待信号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;是发送一个信号，自然会让信号总量加1，&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_t group = dispatch_group_create();   
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);   
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   
    for (int i = 0; i &amp;lt; 100; i++)   
    {   
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   
        dispatch_group_async(group, queue, ^{   
            NSLog(@&amp;quot;%i&amp;quot;,i);   
            sleep(2);   
            dispatch_semaphore_signal(semaphore);   
        });   
    }   
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);   
    dispatch_release(group);   
    dispatch_release(semaphore);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码创建了一个初使值为10的semaphore，每一次for循环都会创建一个新的线程，线程结束的时候会发送一个信号，线程创建之前会信号等待，所以当同时创建了10个线程之后，for循环就会阻塞，等待有线程结束之后会增加一个信号才继续执行，如此就形成了对并发的控制，如上就是一个并发数为10的一个线程队列。&lt;/p&gt;

&lt;h4 id=&#34;pthread-mutex-t:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;pthread_mutex_t&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_NORMAL，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_ERRORCHECK，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型是 PTHREAD_MUTEX_DEFAULT，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;amp;mutex, NULL);

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;amp;mutex);
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;amp;mutex);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;synchronized:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;@synchronized&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nslock:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];
NSLock *lock = [[NSLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;

&lt;h4 id=&#34;nsrecursivelock:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSRecursiveLock&lt;/h4&gt;

&lt;p&gt;NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    static void (^RecursiveMethod)(int);
 
    RecursiveMethod = ^(int value) {
 
        [lock lock];
        if (value &amp;gt; 0) {
 
            NSLog(@&amp;quot;value = %d&amp;quot;, value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };
 
    RecursiveMethod(5);
});
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    sleep(2);
    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];
    if (flag) {
        NSLog(@&amp;quot;lock before date&amp;quot;);
 
        [lock unlock];
    } else {
        NSLog(@&amp;quot;fail to lock before date&amp;quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSRecursiveLock除了实现NSLocking协议的方法外，还提供了两个方法，分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在给定的时间之前去尝试请求一个锁
- (BOOL)lockBeforeDate:(NSDate *)limit
 
// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功
- (BOOL)tryLock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，NSRecursiveLock还声明了一个name属性，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property(copy) NSString *name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用这个字符串来标识一个锁。Cocoa也会使用这个name作为错误描述信息的一部分。&lt;/p&gt;

&lt;h4 id=&#34;nscondition:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSCondition&lt;/h4&gt;

&lt;p&gt;使用NSCondition，实现多线程的同步，即，可实现生产者消费者问题。&lt;/p&gt;

&lt;p&gt;基本思路是，首先要创建公用的NSCondition实例。然后：&lt;/p&gt;

&lt;p&gt;消费者取得锁，取产品，如果没有，则wait，这时会释放锁，直到有线程唤醒它去消费产品；&lt;/p&gt;

&lt;p&gt;生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)conditionTest:(id)sender
{
    NSLog(@&amp;quot;begin condition works!&amp;quot;);
    products = [[NSMutableArray alloc] init];
    condition = [[NSCondition alloc] init];
     
    [NSThread detachNewThreadSelector:@selector(createProducter) toTarget:self withObject:nil];
    [NSThread detachNewThreadSelector:@selector(createConsumenr) toTarget:self withObject:nil];
}
 
- (void)createConsumenr
{
    [condition lock];
    while ([products count] == 0) {
        NSLog(@&amp;quot;wait for products&amp;quot;);
        [condition wait];
    }
    [products removeObjectAtIndex:0];
    NSLog(@&amp;quot;comsume a product&amp;quot;);
    [condition unlock];
}
 
- (void)createProducter
{
    [condition lock];
    [products addObject:[[NSObject alloc] init]];
    NSLog(@&amp;quot;produce a product&amp;quot;);
    [condition signal];
    [condition unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsconditionlock:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSConditionLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
NSConditionLock *theLock = [[NSConditionLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    for (int i=0;i&amp;lt;=2;i++)
    {
        [theLock lock];
        NSLog(@&amp;quot;thread1:%d&amp;quot;,i);
        sleep(2);
        [theLock unlockWithCondition:i];
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [theLock lockWhenCondition:2];
    NSLog(@&amp;quot;thread2&amp;quot;);
    [theLock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsdistributedlock-分布式锁:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSDistributedLock 分布式锁&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>iOS HTTP Multipart Forms POST(头像图片上传)</title>
      <link>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</link>
      <pubDate>Sat, 13 Sep 2014 12:49:42 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</guid>
      <description>&lt;p&gt;由于iOS无法通过html表单来上传图片，因此想要上传图片，必须实现http请求，而不能像其他语言那样通过html表单的post就能上传。&lt;/p&gt;

&lt;p&gt;上传图片的http post请求的格式是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-type: multipart/form-data, boundary=---------------------------14737809831466499882746641449

---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.jpg&amp;quot;
Content-Type: image/jpeg

... contents of boo,jpg ...
---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
---------------------------14737809831466499882746641449
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行是指定了&lt;code&gt;http post&lt;/code&gt;请求的编码方式为&lt;code&gt;multipart/form-data&lt;/code&gt;（上传文件必须用这个）。
&lt;code&gt;boundary= xxx&lt;/code&gt; 说明了&lt;code&gt;xxx&lt;/code&gt;为分界线。比如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt; 就是一个分界线的意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话声明了请求中的一个字段的名称，如&lt;code&gt;info&lt;/code&gt;  以及字段的值，如&lt;code&gt;Hello Boris!&lt;/code&gt;
这里类似&lt;code&gt;form&lt;/code&gt;表单中的&lt;code&gt;&amp;lt;input name=&amp;quot;info&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;Hello Boris!&amp;quot;/&amp;gt;&lt;/code&gt;
中间的空行是必须的。&lt;/p&gt;

&lt;p&gt;不同的字段之间用分界线分开，分界线需要单独一行，如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分界线的下一行，是下一个字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;content-disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.png&amp;quot;
Content-Type: image/png

... contents of boo.png ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里声明了变量&lt;code&gt;pic&lt;/code&gt;，也就是我们要传的文件，上传文件的时候需要在后边指定&lt;code&gt;file name：filename=&amp;quot;boo.png&amp;quot;&lt;/code&gt;
并且需要在下一行指定文件的格式：&lt;code&gt;Content-Type: image/png&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;... contents of boo.png ...&lt;/code&gt;  这里是&lt;code&gt;boo.png&lt;/code&gt;的二进制内容，如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;89504e47 0d0a1a0a 0000000d 49484452 000000b4 000000b4 08020000 00b2af91 65000020 00494441 5478012c dd79b724 6b7616f6 8c888c88 8c9c8733 55ddb1d5 6a0db486 06218401 ......&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在http post请求的结尾，需要有一个分界线，但是是前后都有&amp;ndash;的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上的这些格式，是http的规范，每个空行，空格都是必须的。&lt;/p&gt;

&lt;p&gt;下边是iOS的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 建立请求对象
NSMutableURLRequest * request = [[NSMutableURLRequest alloc] init];
[request setURL:[NSURL URLWithString:kRequestBaseApi]];

// 请求方式
[request setHTTPMethod:@&amp;quot;POST&amp;quot;];
[request setTimeoutInterval:kCLTimeoutInterval];

// 接口参数
NSString *string = [NSString stringWithFormat:@&amp;quot;{\&amp;quot;action\&amp;quot;:\&amp;quot;saveHeadImg\&amp;quot;,\&amp;quot;uid\&amp;quot;:\&amp;quot;%@\&amp;quot;}&amp;quot;, [ClientState shareInstance].currentUID];

// 头标签，分隔线
NSString *boundary = @&amp;quot;---------------------------14737809831466499882746641449&amp;quot;;
NSString *contentType = [NSString stringWithFormat:@&amp;quot;multipart/form-data; boundary=%@&amp;quot;,boundary];
[request addValue:contentType forHTTPHeaderField: @&amp;quot;Content-Type&amp;quot;];

NSMutableData *body = [NSMutableData data];

// 添加接口参数
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;req\&amp;quot;\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;%@\r\n&amp;quot;,string] dataUsingEncoding:NSUTF8StringEncoding]];

// 添加图片data
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;files\&amp;quot;; filename=\&amp;quot;%@\&amp;quot;\r\n&amp;quot;, fileName]
                  dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Type: image/pjpeg\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[NSData dataWithData:imageData]];

// 添加尾部分隔线
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@--\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[request setHTTPBody:body];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于宏</title>
      <link>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</link>
      <pubDate>Sat, 09 Aug 2014 11:38:21 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</guid>
      <description>

&lt;p&gt;C中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)。对于对象宏来说确实相对简单，但却也不是那么简单的查找替换。对象宏一般用来定义一些常数，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define M_PI    3.14159265358979323846264338327950288
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;关键字表明即将开始定义一个宏，紧接着的&lt;code&gt;M_PI&lt;/code&gt;是宏的名字，空格之后的数字是内容。类似这样的&lt;code&gt;#define X A&lt;/code&gt;的宏是比较简单的，在编译时编译器会在语义分析认定是宏后，将X替换为A，这个过程称为宏的展开。比如对于上面的&lt;code&gt;M_PI&lt;/code&gt;直接使用。&lt;/p&gt;

&lt;p&gt;函数宏顾名思义，就是行为类似函数，可以接受参数的宏。具体来说，在定义的时候，如果我们在宏名字后面跟上一对括号的话，这个宏就变成了函数宏。从最简单的例子开始，比如下面这个函数宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DES(x)  x
NSString *name = @&amp;quot;Macro Rookie&amp;quot;;  
NSLog(@&amp;quot;Hello %@&amp;quot;,DES(name));  
// =&amp;gt; NSLog(@&amp;quot;Hello %@&amp;quot;,name);
//   =&amp;gt; Hello Macro Rookie 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏做的事情是，在编译时如果遇到&lt;code&gt;DES&lt;/code&gt;，并且后面带括号，并且括号中的参数个数与定义的相符，那么就将括号中的参数换到定义的内容里去，然后替换掉原来的内容。 具体到这段代码中，&lt;code&gt;DES&lt;/code&gt;接受了一个&lt;code&gt;name&lt;/code&gt;，然后将整个&lt;code&gt;DES(name)&lt;/code&gt;用&lt;code&gt;name&lt;/code&gt;替换掉。多个参数的宏例如这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PLUS(x,y) (x + y)
printf(&amp;quot;%d&amp;quot;,PLUS(3,2));  
// =&amp;gt; printf(&amp;quot;%d&amp;quot;,3 + 2);
//  =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;因为宏展开其实是编辑器的预处理，因此它可以在更高层级上控制程序源码本身和编译流程。而正是这个特点，赋予了宏很强大的功能和灵活度。但是凡事都有两面性，在获取灵活的背后，是以需要大量时间投入以对各种边界情况进行考虑来作为代价的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#define __NSX_PASTE__(A,B) A##B

#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)

#define __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); \
                                 __typeof__(B) __NSX_PASTE__(__b,L) = (B); \
                                (__NSX_PASTE__(__a,L) &amp;lt; __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); \
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;MIN&lt;/code&gt;一共由三个宏定义组合而成。第一个&lt;code&gt;__NSX_PASTE__&lt;/code&gt;里出现的两个连着的井号&lt;code&gt;##&lt;/code&gt;在宏中是一个特殊符号，它表示将两个参数连接起来这种运算。注意函数宏必须是有意义的运算，因此你不能直接写&lt;code&gt;AB&lt;/code&gt;来连接两个参数，而需要写成例子中的&lt;code&gt;A##B&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来是我们调用的两个参数的&lt;code&gt;MIN&lt;/code&gt;，它做的事是调用了另一个三个参数的宏&lt;code&gt;__NSMIN_IMPL__&lt;/code&gt;，其中前两个参数就是我们的输入，而第三个&lt;code&gt;__COUNTER__&lt;/code&gt;是一个预定义的宏，这个值在编译过程中将从&lt;code&gt;0&lt;/code&gt;开始计数，每次被调用时加&lt;code&gt;1&lt;/code&gt;。因为唯一性，所以很多时候被用来构造独立的变量名称。有了上面的基础，再来看最后的实现宏就很简单了。整体思路和前面的实现和之前的GNUC MIN是一样的，区别在于为变量名&lt;code&gt;__a&lt;/code&gt;和&lt;code&gt;__b&lt;/code&gt;添加了一个计数后缀，这样大大避免了变量名相同而导致问题的可能性。&lt;/p&gt;

&lt;h3 id=&#34;log:88505ded347af25f6a47875a4eb189b9&#34;&gt;Log&lt;/h3&gt;

&lt;p&gt;我们通过宏，可以很简单地完成对NSLog原生行为的改进，优雅，高效。只需要在预编译的pch文件中加上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//A better version of NSLog
#define NSLog(format, ...) do {  \
                              fprintf(stderr, &amp;quot;&amp;lt;%s : %d&amp;gt; %s\n&amp;quot;,   \
                              [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \
                              __LINE__, __func__);\
                              (NSLog)((format), ##__VA_ARGS__);   \
                              fprintf(stderr, &amp;quot;-------\n&amp;quot;);   \
                             } while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是定义部分，第2行的&lt;code&gt;NSLog(format, ...)&lt;/code&gt;。我们看到的是一个函数宏，但是它的参数比较奇怪，第二个参数是&lt;code&gt;...&lt;/code&gt;，在宏定义（其实也包括函数定义）的时候，写为&lt;code&gt;...&lt;/code&gt;的参数被叫做可变参数(variadic)。可变参数的个数不做限定。在这个宏定义中，除了第一个参数format将被单独处理外，接下来输入的参数将作为整体一并看待。回想一下NSLog的用法，我们在使用NSLog时，往往是先给一个format字符串作为第一个参数，然后根据定义的格式在后面的参数里跟上写要输出的变量之类的。这里第一个格式化字符串即对应宏里的format，后面的变量全部映射为&lt;code&gt;...&lt;/code&gt;作为整体处理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__FILE__&lt;/code&gt;返回当前文件的绝对路径，&lt;code&gt;__LINE__&lt;/code&gt;返回展开该宏时在文件中的行数，&lt;code&gt;__func__&lt;/code&gt;是改宏所在scope的函数名称。我们在做Log输出时如果带上这这三个参数，便可以加快解读Log，迅速定位。关于编译器预定义的Log以及它们的一些实现机制，感兴趣的同学可以移步到gcc文档的PreDefine页面和clang的Builtin Macro进行查看。在这里我们将格式化输出的三个参数分别设定为文件名的最后一个部分（因为绝对路径太长很难看），行数，以及方法名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define NSLogRect(rect) NSLog(@&amp;quot;%s x:%.4f, y:%.4f, w:%.4f, h:%.4f&amp;quot;, #rect, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)
#define NSLogSize(size) NSLog(@&amp;quot;%s w:%.4f, h:%.4f&amp;quot;, #size, size.width, size.height)
#define NSLogPoint(point) NSLog(@&amp;quot;%s x:%.4f, y:%.4f&amp;quot;, #point, point.x, point.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;宏:88505ded347af25f6a47875a4eb189b9&#34;&gt;宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//获取系统版本  
#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]  
#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion]  

//获取当前语言  
#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])  

//判断是否 Retina屏、设备是否%fhone 5、是否是iPad  
#define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)  
#define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO)  
#define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)     

// rgb颜色转换（16进制-&amp;gt;10进制）  
#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16))/255.0 green:((float)((rgbValue &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8))/255.0 blue:((float)(rgbValue &amp;amp; 0xFF))/255.0 alpha:1.0]  

//带有RGBA的颜色设置  
#define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]  

// 获取RGB颜色  
#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]  
#define RGB(r,g,b) RGBA(r,g,b,1.0f)

  //由角度获取弧度 有弧度获取角度  
#define degreesToRadian(x) (M_PI * (x) / 180.0)  
#define radianToDegrees(radian) (radian*180.0)/(M_PI)  

#define DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, onceBlock);

DISPATCH_ONCE_BLOCK(^{
//code
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSNotification 通知</title>
      <link>http://felixmlians.github.io/2014/07/03/nsnotification-%E9%80%9A%E7%9F%A5/</link>
      <pubDate>Thu, 03 Jul 2014 18:56:41 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/07/03/nsnotification-%E9%80%9A%E7%9F%A5/</guid>
      <description>

&lt;p&gt;NSNotification 一个对象通知另外一个对象，可以用来传递参数、通信等作用，与delegate的一对一不同，通知是一对多的。在一个对象中注册了通知，那么其他任意对象都可以来对这个对象发出通知。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSNotificationCenter&lt;/li&gt;
&lt;li&gt;NSNotificationQueue&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nsnotificationcenter:cd29d22e126672704ff5fec0205d1cc7&#34;&gt;NSNotificationCenter&lt;/h3&gt;

&lt;p&gt;注册一个通知：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self  
                                         selector:@selector(getNotification:) 
                                             name:@&amp;quot;notificationMethon&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSNorificationCenter是一个单例，我们可以通过defaultCenter来获取到通知中心这个单例；&lt;/p&gt;

&lt;p&gt;需要注意的是当我们添加一个通知以后，必须在合适的位置将通知移除，不然下次再添加这个通知并调用时，这个通知将会被调用多次，而这一般不是我们所预料的。一般我们在对象的析构函数中将通知移除，我们可以选择将这个对象中的所有通知移除，也可以选择一个一个按照通知的name来移除。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] removeObserver:self];

[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;notificationMethon&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发出通知就是通过 &lt;code&gt;postNotificationName&lt;/code&gt; 函数来实现，这里发出的通知是同步操作，也就是只有当发出的通知执行完成后才会继续执行下面的代码。&lt;/p&gt;

&lt;p&gt;这是发出通知以后会调用的方法，在多线程操作时，发出通知的对象和接收通知的对象处于同一个线程。
在这个响应的方法中有一个参数(NSNotification *)info这个参数是NSNotification类型的，这个类型有几个属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (readonly, copy) NSString *name;
@property (nullable, readonly, retain) id object;
@property (nullable, readonly, copy) NSDictionary *userInfo;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nsnotificationqueue:cd29d22e126672704ff5fec0205d1cc7&#34;&gt;NSNotificationQueue&lt;/h3&gt;

&lt;p&gt;NSNotificationQueue就有一些区别，他有两个非常重要的特点：即通告的聚结和异步发送。聚结是把和刚进入队列的通告相类似的其它通告从队列中移除的过程。如果一个新的通告和已经在队列中的通告相类似，则新的通告不进入队列，而所有类似的通告（除了队列中的第一个通告以外）都被移除。然而，您不应该依赖于这个特殊的聚结行为。
而异步发送则很好理解了，也就是说发出通知以后立刻返回，也就是是继续执行下面的代码，并不管通知发出后的具体情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSNotification *notifacation = [[NSNotification alloc]initWithName:@&amp;quot;notificationName&amp;quot; object:nil userInfo:@{@&amp;quot;key1&amp;quot;:@&amp;quot;value1&amp;quot;}];
[[NSNotificationQueue defaultQueue] enqueueNotification:notifacation postingStyle:NSPostWhenIdle];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过，NSNotificationQueue的defaultQueue来获取到这个通知队列，然后调用enqueueNotification来发出通知，我们可以看到第二个参数postingStyle,这个参数是一个枚举，他可以是以下三个值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef NS_ENUM(NSUInteger, NSPostingStyle) {
    NSPostWhenIdle = 1,
    NSPostASAP = 2,
    NSPostNow = 3
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个不同的值是有一定区别的。（以下内容摘抄自网络）&lt;/p&gt;

&lt;p&gt;尽快发送
以NSPostASAP风格进入队列的通告会在运行循环的当前迭代完成时被发送给通告中心，如果当前运行循环模式和请求的模式相匹配的话（如果请求的模式和当前模式不同，则通告在进入请求的模式时被发出）。由于运行循环在每个迭代过程中可能进行多个调用分支（callout），所以在当前调用分支退出及控制权返回运行循环时，通告可能被分发，也可能不被分发。其它的调用分支可能先发生，比如定时器或由其它源触发了事件，或者其它异步的通告被分发了。&lt;/p&gt;

&lt;p&gt;您通常可以将NSPostASAP风格用于开销昂贵的资源，比如显示服务器。如果在运行循环的一个调用分支过程中有很多客户代码在窗口缓冲区中进行描画，在每次描画之后将缓冲区的内容刷新到显示服务器的开销是很昂贵的。在这种情况下，每个draw&amp;hellip;方法都会将诸如“FlushTheServer” 这样的通告排入队列，并指定按名称和对象进行聚结，以及使用NSPostASAP风格。结果，在运行循环的最后，那些通告中只有一个被派发，而窗口缓冲区也只被刷新一次。&lt;/p&gt;

&lt;p&gt;空闲时发送
以NSPostWhenIdle风格进入队列的通告只在运行循环处于等待状态时才被发出。在这种状态下，运行循环的输入通道中没有任何事件，包括定时器和异步事件。以NSPostWhenIdle风格进入队列的一个典型的例子是当用户键入文本、而程序的其它地方需要显示文本字节长度的时候。在用户输入每一个字符后都对文本输入框的尺寸进行更新的开销是很大的（而且不是特别有用），特别是当用户快速输入的时候。在这种情况下，Cocoa会在每个字符键入之后，将诸如“ChangeTheDisplayedSize”这样的通告进行排队，同时把聚结开关打开，并使用NSPostWhenIdle风格。当用户停止输入的时候，队列中只有一个“ChangeTheDisplayedSize”通告（由于聚结的原因）会在运行循环进入等待状态时被发出，显示部分也因此被刷新。请注意，运行循环即将退出（当所有的输入通道都过时的时候，会发生这种情况）时并不处于等待状态，因此也不会发出通告。&lt;/p&gt;

&lt;p&gt;立即发送
以NSPostNow风格进入队列的通告会在聚结之后，立即发送到通告中心。您可以在不需要异步调用行为的时候 使用NSPostNow风格（或者通过NSNotificationCenter的postNotification:方法来发送）。在很多编程环境下，我们不仅允许同步的行为，而且希望使用这种行为：即您希望通告中心在通告派发之后返回，以便确定观察者对象收到通告并进行了处理。当然，当您希望通过聚结移除队列中类似的通告时，应该用enqueueNotification&amp;hellip;方法，且使用NSPostNow风格，而不是使用postNotification:方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有关block</title>
      <link>http://felixmlians.github.io/2014/06/29/%E6%9C%89%E5%85%B3block/</link>
      <pubDate>Sun, 29 Jun 2014 20:36:29 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/29/%E6%9C%89%E5%85%B3block/</guid>
      <description>

&lt;h4 id=&#34;block发生引用循环:cc738f5dd4a4ad7b4748fcc0c94d63e1&#34;&gt;block发生引用循环&lt;/h4&gt;

&lt;p&gt;一个对象中强引用了block，在block中又使用了该对象，就会发生循环引用。解决方法就是将该对象使用 &lt;code&gt;__weak&lt;/code&gt;或者 &lt;code&gt;__block&lt;/code&gt; 修饰符修饰后在block中使用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;id weak weakSelf = self&lt;/code&gt;, 或者 &lt;code&gt;weak __typeof(&amp;amp;*self)weakSelf = self&lt;/code&gt; (可以将该方法设置为宏）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id __block weakSelf = self&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;在block内修改block外部变量:cc738f5dd4a4ad7b4748fcc0c94d63e1&#34;&gt;在block内修改block外部变量&lt;/h4&gt;

&lt;p&gt;默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 &lt;code&gt;__block&lt;/code&gt; 来让其写操作生效；&lt;/p&gt;

&lt;h4 id=&#34;使用系统的某些block-api的引用循环问题:cc738f5dd4a4ad7b4748fcc0c94d63e1&#34;&gt;使用系统的某些block api的引用循环问题&lt;/h4&gt;

&lt;p&gt;系统的block api中，UIView的block版本写动画时不需要考虑。&lt;/p&gt;

&lt;p&gt;所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block强引用 self）没有问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; 

[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.property = foo; }]; 

[[NSNotificationCenter defaultCenter] addObserverForName:@&amp;quot;cl_Notification&amp;quot; 
                                                  object:nil 
                           queue:[NSOperationQueue mainQueue]
                                              usingBlock:^(NSNotification * notification) {
                                                    self.property = boo; }]; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你使用了一些参数中可能含有ivar的体统api，如GCD、 NSNotificationCenter就要小心。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__weak __typeof__(self) weakSelf = self;
dispatch_group_async(_operationsGroup, _operationsQueue, ^
{
__typeof__(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doSomethingElse];
} );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; __weak __typeof__(self) weakSelf = self;
  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&amp;quot;testKey&amp;quot;
                                                                object:nil
                                                                 queue:nil
                                                            usingBlock:^(NSNotification *note) {
      __typeof__(self) strongSelf = weakSelf;
      [strongSelf dismissModalViewControllerAnimated:YES];
  }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;self&amp;ndash;&amp;gt; _observer &amp;ndash;&amp;gt; block &amp;ndash;&amp;gt; self&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>runloop 简介</title>
      <link>http://felixmlians.github.io/2014/06/26/runloop-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Jun 2014 19:49:43 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/26/runloop-%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;h4 id=&#34;runloop-和线程有什么关系:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop 和线程有什么关系？&lt;/h4&gt;

&lt;p&gt;总的来说，Runloop,如其名，表示着一直在运行的循环。实际上，runloop和线程是紧密相连的，可以这样说runloop是为了线程而生，没有线程，它就没有存在的必要。每个线程，包括程序的主线程（main thread)都有与之对应的runloop对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主线程的runloop默认是启动的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;iOS的应用程序里面，程序启动后会有一个如下的 &lt;code&gt;main()&lt;/code&gt; 函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了，为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对其他线程来说，runloop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在任何一个cocoa程序的线程中，都可以通过以下代码来获取到当前的runloop。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;    NSRunLoop *runloop = [NSRunLoop currentRunLoop];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;runloop的mode主要来指定事件在运行中的优先级:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop的mode主要来指定事件在运行中的优先级&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态&lt;/li&gt;
&lt;li&gt;UITrackingRunLoopMode：ScrollView滑动时&lt;/li&gt;
&lt;li&gt;UIInitializationRunLoopMode：启动时&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;苹果公开提供的 Mode 有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;runloop-只能运行在一中mode-中:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop 只能运行在一中mode 中&lt;/h4&gt;

&lt;p&gt;RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。&lt;/p&gt;

&lt;p&gt;如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。&lt;/p&gt;

&lt;p&gt;同时因为mode还是可定制的，所以：&lt;/p&gt;

&lt;p&gt;Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将timer添加到NSDefaultRunLoopMode中
[NSTimer scheduledTimerWithTimeInterval:1.0
                                 target:self
                               selector:@selector(timerTick:)
                               userInfo:nil
                                repeats:YES];
//然后再添加到NSRunLoopCommonModes里
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0
                                         target:self
                                       selector:@selector(timerTick:)
                                       userInfo:nil
                                        repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;runloop内部实现:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop内部实现&lt;/h4&gt;

&lt;p&gt;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但不退出，通常的代码逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;objc-管理对象内存:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;objc 管理对象内存&lt;/h4&gt;

&lt;p&gt;通过retainCount 的机制来决定对象是否需要释放。每次runloop的时候，都会检查对象的retainCount，如果retainCount为0，说明该对象没有地方需要继续使用了，可以释放掉了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>类中增加实例变量</title>
      <link>http://felixmlians.github.io/2014/06/23/%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 23 Jun 2014 18:34:54 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/23/%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</guid>
      <description>

&lt;h4 id=&#34;能否向编译后得到的类中增加实例变量-能否向运行时创建的类中增加实例变量:e95b6352016c71c7e0e43fef78963e01&#34;&gt;能否向编译后得到的类中增加实例变量？能否向运行时创建的类中增加实例变量？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;不能向编译后得到的类中增加实例变量&lt;/li&gt;
&lt;li&gt;能向运行时创建的类中添加实例变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译后的类已经注册在 &lt;code&gt;runtime&lt;/code&gt; 中，类结构体中的 &lt;code&gt;objc_ivar_list&lt;/code&gt; 实例变量的链表和 &lt;code&gt;instance_size&lt;/code&gt; 实例变量的内存大小已经确定，同时 &lt;code&gt;runtime&lt;/code&gt; 会调用 &lt;code&gt;class_setWeakIvarLayout&lt;/code&gt; 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；&lt;/li&gt;
&lt;li&gt;运行时创建的类是可以添加实例变量，调用 &lt;code&gt;class_addIvar&lt;/code&gt; 函数。但是得在调用 &lt;code&gt;objc_allocateClassPair&lt;/code&gt; 之后，&lt;code&gt;objc_registerClassPair&lt;/code&gt; 之前，原因同上。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>什么时候会报unrecognized selector的异常？</title>
      <link>http://felixmlians.github.io/2014/06/22/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%8A%A5unrecognized-selector%E7%9A%84%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sun, 22 Jun 2014 19:59:51 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/22/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%8A%A5unrecognized-selector%E7%9A%84%E5%BC%82%E5%B8%B8/</guid>
      <description>&lt;p&gt;简单来说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objc&lt;/code&gt;是动态语言，每个方法在运行时会被动态转为消息发送，即：&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;objc&lt;/code&gt;在向一个对象发送消息时，&lt;code&gt;runtime&lt;/code&gt;库会根据对象的&lt;code&gt;isa&lt;/code&gt;指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常&lt;code&gt;unrecognized selector sent to XXX&lt;/code&gt; 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Method resolution&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;objc&lt;/code&gt;运行时会调用&lt;code&gt;+resolveInstanceMethod:&lt;/code&gt;或者 &lt;code&gt;+resolveClassMethod:&lt;/code&gt;，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Fast forwarding&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果目标对象实现了&lt;code&gt;-forwardingTargetForSelector:&lt;/code&gt;，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Normal forwarding&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这一步是Runtime最后一次给你挽救的机会。首先它会发送&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;消息获得函数的参数和返回值类型。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;返回nil，Runtime则会发出&lt;code&gt;-doesNotRecognizeSelector:&lt;/code&gt;消息，程序这时也就挂掉了。&lt;/p&gt;

&lt;p&gt;如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送&lt;code&gt;-forwardInvocation:&lt;/code&gt;消息给目标对象。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>