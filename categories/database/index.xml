<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on Felix&#39;s  Space</title>
    <link>http://felixmlians.github.io/categories/database/</link>
    <description>Recent content in Database on Felix&#39;s  Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012 - 2018, Felix M Lians; all rights reserved.</copyright>
    <lastBuildDate>Wed, 22 Oct 2014 17:27:18 +0800</lastBuildDate>
    <atom:link href="http://felixmlians.github.io/categories/database/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SQLite（简介）</title>
      <link>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 22 Oct 2014 17:27:18 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;p&gt;SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。
就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。&lt;/p&gt;

&lt;p&gt;所有教程参考地址： &lt;a href=&#34;http://www.runoob.com/sqlite/sqlite-intro.html&#34;&gt;http://www.runoob.com/sqlite/sqlite-intro.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：&lt;/p&gt;

&lt;h4 id=&#34;ddl-数据定义语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DDL - 数据定义语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;CREATE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一个新的表，一个表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ALTE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改数据库中的某个已有的数据库对象，比如一个表。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DROP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除整个表，或者表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dml-数据操作语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DML - 数据操作语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;INSERT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一条记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;UPDAT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DELETE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dql-数据查询语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DQL - 数据查询语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SELECT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从一个或多个表中检索某些记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;在-mac-os-x-上安装-sqlite:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;在 Mac OS X 上安装 SQLite&lt;/h4&gt;

&lt;p&gt;最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请访问 SQLite 下载页面，从源代码区下载 sqlite-autoconf-*.tar.gz。&lt;/li&gt;
&lt;li&gt;步骤如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	$tar xvfz sqlite-autoconf-3071502.tar.gz
	$cd sqlite-autoconf-3071502
	$./configure --prefix=/usr/local
	$make
	$make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sqlite3
SQLite version 3.7.15.2 2013-01-09 11:53:05
Enter &amp;quot;.help&amp;quot; for instructions
Enter SQL statements terminated with a &amp;quot;;&amp;quot;
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令-1:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;获取可用的点命令的清单，可以在任何时候输入 &amp;ldquo;.help&amp;rdquo;。&lt;code&gt;sqlite&amp;gt;.help&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 .show 命令，来查看 SQLite 命令提示符的默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.show
     echo: off
  explain: off
  headers: off
     mode: column
nullvalue: &amp;quot;&amp;quot;
   output: stdout
separator: &amp;quot;|&amp;quot;
    width:
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;确保 sqlite&amp;gt; 提示符与点命令之间没有空格，否则将无法正常工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用下列的点命令来格式化输出为本教程下面所列出的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.header on
sqlite&amp;gt;.mode column
sqlite&amp;gt;.timer on
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面设置将产生如下格式的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID          NAME        AGE         ADDRESS     SALARY
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0
2           Allen       25          Texas       15000.0
3           Teddy       23          Norway      20000.0
4           Mark        25          Rich-Mond   65000.0
5           David       27          Texas       85000.0
6           Kim         22          South-Hall  45000.0
7           James       24          Houston     10000.0
CPU Time: user 0.000000 sys 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主表中保存数据库表的关键信息，并把它命名为 sqlite_master。如要查看表概要，可按如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.schema sqlite_master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将产生如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE sqlite_master (
  type text,
  name text,
  tbl_name text,
  rootpage integer,
  sql text
);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于FMDB/SQLite</title>
      <link>http://felixmlians.github.io/2014/07/18/%E5%85%B3%E4%BA%8Efmdb/sqlite/</link>
      <pubDate>Fri, 18 Jul 2014 21:35:38 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/07/18/%E5%85%B3%E4%BA%8Efmdb/sqlite/</guid>
      <description>

&lt;p&gt;到&lt;a href=&#34;https://github.com/ccgus/fmdb&#34;&gt;https://github.com/ccgus/fmdb&lt;/a&gt; 下载源文件，然后直接将fmdb文件夹拖入到你的工程就OK。
当然你需要添加依赖库：libsqlite3.dylib&lt;/p&gt;

&lt;p&gt;拖入源文件，并且添加依赖库以后你就可以使用FMDB了，引用头文件
&lt;code&gt;#import &amp;quot;FMDB.h&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;USAGE&lt;/h2&gt;

&lt;p&gt;在FMDB中主要有三个类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;FMDatabase - 简单的说这个类就是代表了数据库&lt;/li&gt;
&lt;li&gt;FMResultSet - 这个类表示查询操作的结果&lt;/li&gt;
&lt;li&gt;FMDatabaseQueue - 多线程操作的时候你会用到这个类，并且这是线程安全的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;创建数据库:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;创建数据库&lt;/h3&gt;

&lt;p&gt;你需要使用一个path来创建一个本地FMDatabase数据库，这个path有三种类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以使用一个本地的地址来创建这个数据库，这个地址不一定真实存在，如果不存在，那么FMDB会创建这个数据库并返回，存在则直接返回这个数据库。&lt;/li&gt;
&lt;li&gt;一个空字符串@&amp;ldquo;&amp;rdquo;.FMDB会在本地创建一个临时的数据库，当数据库关闭的时候会删除这个数据库。&lt;/li&gt;
&lt;li&gt;NULL.如果你将这个path填的是NULL，那么这个数据被创建在内存中，数据库关闭的时候被销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(更多信息关于临时数据库和在内存中的数据库，你可以阅读这篇文档 &lt;a href=&#34;http://www.sqlite.org/inmemorydb.html&#34;&gt;http://www.sqlite.org/inmemorydb.html&lt;/a&gt; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMDatabase *db = [FMDatabase databaseWithPath:@&amp;quot;/tmp/tmp.db&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;打开数据库:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;打开数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (![db open]) {
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;executing-updates:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Executing Updates&lt;/h3&gt;

&lt;p&gt;所有不是select操作的操作都算update. 包括 CREATE, UPDATE, INSERT, ALTER, COMMIT, BEGIN, DETACH, DELETE, DROP, END, EXPLAIN, VACUUM, and REPLACE ····换句话说也就是如果你的操作不是以SELECT开头的都是update操作.&lt;/p&gt;

&lt;p&gt;update操作返回一个布尔值，YES表示操作成功，NO表示你可以遇到了一些错误.FMDatabase有两个方法 -lastErrorMessage 和 -lastErrorCode，你可以使用这两个方法来查看错误。&lt;/p&gt;

&lt;h3 id=&#34;executing-queries:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Executing Queries&lt;/h3&gt;

&lt;p&gt;SELECT 查询使用 -executeQuery&amp;hellip; 方法.&lt;/p&gt;

&lt;p&gt;查询成功返回 FMResultSet,失败则是返回nil.
同样你可以使用FMDatabase的两个方法 -lastErrorMessage and -lastErrorCode 来查找原因。&lt;/p&gt;

&lt;p&gt;你需要用一个循环来获取到查询到的每一个值。like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMResultSet *s = [db executeQuery:@&amp;quot;SELECT * FROM myTable&amp;quot;];
while ([s next]) {
    //retrieve values for each record
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FMResultSet 有许多类型用来返回不同类型的查询结果的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;intForColumn:
longForColumn:
longLongIntForColumn:
boolForColumn:
doubleForColumn:
stringForColumn:
dateForColumn:
dataForColumn:
dataNoCopyForColumn:
UTF8StringForColumnName:
objectForColumnName:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的每个方法都有对应的 {type}ForColumnIndex: 上面那一溜方法是用例的名字来获取数据，而这个方法则是用数据在查询结果中对应的位置来获取数据.&lt;/p&gt;

&lt;h3 id=&#34;closing:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Closing&lt;/h3&gt;

&lt;p&gt;用完了FMDB记得关闭&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[db close];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;批处理:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;批处理&lt;/h3&gt;

&lt;p&gt;FMDatabase的方法 executeStatements:withResultBlock:可以使用字符串来同时处理多条指令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *sql = @&amp;quot;create table test1 (id integer primary key autoincrement, x text);&amp;quot;
                 &amp;quot;create table test2 (id integer primary key autoincrement, y text);&amp;quot;
                 &amp;quot;create table test3 (id integer primary key autoincrement, z text);&amp;quot;
                 &amp;quot;insert into test1 (x) values (&#39;XXX&#39;);&amp;quot;
                 &amp;quot;insert into test2 (y) values (&#39;YYY&#39;);&amp;quot;
                 &amp;quot;insert into test3 (z) values (&#39;ZZZ&#39;);&amp;quot;;

success = [db executeStatements:sql];

sql = @&amp;quot;select count(*) as count from test1;&amp;quot;
       &amp;quot;select count(*) as count from test2;&amp;quot;
       &amp;quot;select count(*) as count from test3;&amp;quot;;

success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) {
    NSInteger count = [dictionary[@&amp;quot;count&amp;quot;] integerValue];
    XCTAssertEqual(count, 1, @&amp;quot;expected one record for dictionary %@&amp;quot;, dictionary);
    return 0;
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据处理:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;数据处理&lt;/h3&gt;

&lt;p&gt;你必须使用标准的SQLite的标准语法，像下面那样（而不是SQL中那样）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO myTable VALUES (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘？’这个符号表示插入数据的替代符，操作方法会接收参数来替代这个符号 (或者是代表这些参数的，比如说：NSArray, NSDictionary, va_list).&lt;/p&gt;

&lt;p&gt;OC中你可以像下面这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSInteger identifier = 42;
NSString *name = @&amp;quot;Liam O&#39;Flaherty (\&amp;quot;the famous Irish author\&amp;quot;)&amp;quot;;
NSDate *date = [NSDate date];
NSString *comment = nil;

BOOL success = [db executeUpdate:@&amp;quot;INSERT INTO authors (identifier, name, date, comment) VALUES (?, ?, ?, ?)&amp;quot;, @(identifier), name, date, comment ?: [NSNull null]];
if (!success) {
NSLog(@&amp;quot;error = %@&amp;quot;, [db lastErrorMessage]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note:这里需要注意的是，如果是基本数据类型比如说&lt;code&gt;NSInteger&lt;/code&gt;，你需要转化为&lt;code&gt;NSNumber&lt;/code&gt;。
如果是插入nil，那么你不能直接插入nil，而是需要插入&lt;code&gt;[NSNull null]&lt;/code&gt;，像上面那个例子中写的是：&lt;code&gt;comment ?: [NSNull null]&lt;/code&gt;，那么如果commit是nil的话则会插入nil，反之则会插入commit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这种书写方法和上面表达的是同一个意思。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO authors (identifier, name, date, comment) VALUES (:identifier, :name, :date, :comment)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像上面这种写法参数是以冒号开头的，SQLite支持其他字符，但是在字典中key都是以冒号为前缀的，所以你的字典key中不要包含冒号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSDictionary *arguments = @{@&amp;quot;identifier&amp;quot;: @(identifier), @&amp;quot;name&amp;quot;: name, @&amp;quot;date&amp;quot;: date, @&amp;quot;comment&amp;quot;: comment ?: [NSNull null]};
BOOL success = [db executeUpdate:@&amp;quot;INSERT INTO authors (identifier, name, date, comment) VALUES (:identifier, :name, :date, :comment)&amp;quot; withParameterDictionary:arguments];
if (!success) {
NSLog(@&amp;quot;error = %@&amp;quot;, [db lastErrorMessage]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最关键的一点就是：千万不要用NSString的方法比如说 stringWithFormat来手动插入参数，必须要使用Values(?，?)这样的方法，把？当作替代符。&lt;/p&gt;

&lt;h3 id=&#34;fmdatabasequeue-是线程安全的:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;FMDatabaseQueue 是线程安全的&lt;/h3&gt;

&lt;p&gt;不要在多个线程之间使用同一个 FMDatabase对象，最好是每一个线程都有一个独立的 FMDatabase对象，如果你在多线程之间使用同一个对象，那么会有不好的事情发生。
如果你需要在多线程中使用 FMDatabase,那么请使用 FMDatabaseQueue，下面是他的使用方法:&lt;/p&gt;

&lt;p&gt;首先创建你的线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，像这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[queue inDatabase:^(FMDatabase *db) {
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @1];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @2];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @3];

FMResultSet *rs = [db executeQuery:@&amp;quot;select * from foo&amp;quot;];
while ([rs next]) {
    …
}
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An easy way to wrap things up in a transaction can be done like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[queue inTransaction:^(FMDatabase *db, BOOL *rollback) {
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @1];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @2];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @3];

if (whoopsSomethingWrongHappened) {
    *rollback = YES;
    return;
}
// etc…
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @4];
}];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>