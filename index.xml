<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Felix&#39;s  Space</title>
    <link>http://felixmlians.github.io/</link>
    <description>Recent content on Felix&#39;s  Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012 - 2018, Felix M Lians; all rights reserved.</copyright>
    <lastBuildDate>Sun, 01 Mar 2015 12:15:44 +0800</lastBuildDate>
    <atom:link href="http://felixmlians.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>iOS 证书以及迁移到新电脑</title>
      <link>http://felixmlians.github.io/2015/03/01/ios-%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</link>
      <pubDate>Sun, 01 Mar 2015 12:15:44 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/03/01/ios-%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;WARNING：Distribution Certification只有配置证书的电脑才可使用，因此即使导出导出Keychain安装到其他电脑上，其他电脑也不可能具有证书的权限。&lt;strong&gt;（新电脑要发布版本需要重新生成证书）&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;1-certification-证书:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;1. Certification(证书)&lt;/h4&gt;

&lt;p&gt;证书是对电脑开发资格的认证，每个开发者帐号有一套，分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer Certification(开发证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装在电脑上提供权限：开发人员通过设备进行真机测试。
可以生成副本供多台电脑安装；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distribution Certification(发布证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装在电脑上提供发布iOS程序的权限：开发人员可以制做测试版和发布版的程序。&lt;/p&gt;

&lt;p&gt;不可生成副本，仅有配置该证书的电脑才可使用；（副本制做介绍在下面Keychain中介绍）&lt;/p&gt;

&lt;h4 id=&#34;2-provisioning-profile-授权文件:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;2. Provisioning Profile(授权文件)&lt;/h4&gt;

&lt;p&gt;授权文件是对设备如iPod Touch、iPad、iPhone的授权，文件内记录的是设备的UDID和程序的App Id，即：使被授权的设备可以安装或调试Bundle identifier与授权文件中记录的App Id对应的程序。&lt;/p&gt;

&lt;p&gt;开发者帐号在创建授权文件时候会选择App Id，（开发者帐号下App Id中添加，单选）和UDID（开发者帐号下Devices中添加最多100个，多选）。&lt;/p&gt;

&lt;p&gt;授权文件分为两种，对应相应的证书使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer Provisioning Profile(开发授权文件)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在装有开发证书或副本的电脑上使用，开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中，即可进行真机测试。&lt;/p&gt;

&lt;p&gt;注意：确保电脑有权限真机调试，即安装了开发证书或副本；在开发工具中程序的Bundle identifier和选中使用的授权文件的App Id要一致；连接调试的设备的UDID在选中的授权文件中有记录。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distribution Provisioning Profile(发布授权文件)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在装有发布证书的电脑上（即配置证书的电脑，只有一台）制做测试版和发布版的程序。&lt;/p&gt;

&lt;p&gt;发布版就是发布到App Store上的程序文件，开发者帐号创建授权文件时选择store选项，选择App Id，无需选择UDID；&lt;/p&gt;

&lt;p&gt;测试版就是在发布之前交给测试人员可同步到设备上的程序文件，开发者帐号创建授权文件时选择AdHoc，选择App Id和UDID；只有选中的UDID对应的设备才可能安装上通过该授权文件制做的程序。&lt;/p&gt;

&lt;h4 id=&#34;3-keychain-开发密钥:f838faa4b7dbcdab7b27ff1aa0caa800&#34;&gt;3. Keychain(开发密钥)&lt;/h4&gt;

&lt;p&gt;安 装证书成功的情况下证书下都会生成Keychain，上面提到的证书副本（导出证书重新命名）就是通过配置证书的电脑导出Keychain（就是.p12 文件）安装到其他机子上，让其他机子得到证书对应的权限。Developer Certification就可以制做副本Keychain分发到其他电脑上安装，使其可以进行真机测试。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;导出私钥和数字证书是为安全保存和能够在多台电脑上进行工作。打开Keychain Access应用选择’KEY’分类。&lt;/li&gt;
&lt;li&gt;右键点击和你iphone开发证书关联的私钥，并在弹出菜单中选择导出选项。&lt;/li&gt;
&lt;li&gt;使用(.p12)保存包含了你个人信息的钥匙。&lt;/li&gt;
&lt;li&gt;你将会被提示创建一个密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在可以通过.p12文件在不同系统之间传输。双击.p12在其他系统上进行安装。输入你在step4输入的密码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>When you are old</title>
      <link>http://felixmlians.github.io/2015/01/01/when-you-are-old/</link>
      <pubDate>Thu, 01 Jan 2015 00:00:36 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2015/01/01/when-you-are-old/</guid>
      <description>&lt;p&gt;Another year,so many things changed,so many people left,I don&amp;rsquo;t know what to do,but carry on and on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Viva la vida!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        When you are old and grey and full of sleep
　　　　 And nodding by the fire,take down this book
　　　　 And slowly read,and dream of the soft look
　　　　 Your eyes had once, and of their shadows deep;
　　　　
　　　　 How many loved your moments of glad grace,
　　　　 And loved your beauty with love false or true,
　　　　 But one man loved the pilgrim soul in you,
　　　　 And loved the sorrows of your changing face;
　　　　
　　　　 And bending down beside the glowing bars,
　　　　 Murmur,a little sadly,how love fled
　　　　 And paced upon the mountains overhead
　　　　 And hid his face amid a crowd of stars.
　　
　　(BY William Butler Yeats)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 截屏拼图</title>
      <link>http://felixmlians.github.io/2014/12/22/ios-%E6%88%AA%E5%B1%8F%E6%8B%BC%E5%9B%BE/</link>
      <pubDate>Mon, 22 Dec 2014 11:22:30 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/12/22/ios-%E6%88%AA%E5%B1%8F%E6%8B%BC%E5%9B%BE/</guid>
      <description>

&lt;h4 id=&#34;1-普通界面:793ee16878053e99cf22e48f2d18d892&#34;&gt;1. 普通界面&lt;/h4&gt;

&lt;h5 id=&#34;ios-7-以后截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;ios 7 以后截图&lt;/h5&gt;

&lt;p&gt;ios7中添加了调用 &lt;code&gt;snapshotViewAfterScreenUpdates&lt;/code&gt; 创建一个复合视图的快照。然后返回一个&lt;code&gt;uiview&lt;/code&gt;对象来表示调用视图的整体外观。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Supplying YES for -snapshotViewAfterScreenUpdates: means it needs a trip back to the runloop to actually draw the image. If you supply NO, it will try immediately, but if your view is off screen or otherwise hasn&amp;rsquo;t yet drawn to the screen, the snapshot will be empty.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为返回的是一个view对象,所以,你可以更改它以及它的layer属性.但是呢,你不能够修改它的layer的content属性;如果你试图这么做,将不会有任何效果.如果当前的view还没有渲染,或者这么说吧,因为还没有出现在屏幕上,那么,这个截取的view将不会有能显示的content.&lt;/p&gt;

&lt;p&gt;如果你想要加载一个图形效果,比如blur,请使用这个方法 &lt;code&gt;drawViewHierarchyInRect:afterScreenUpdates:&lt;/code&gt; 来代替.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;quot;UIImage+ImageEffects.h&amp;quot;

- (void)createBlurredSnapshot {
    
    UIGraphicsBeginImageContextWithOptions(self.targetImageView.bounds.size, NO, 0);
    
    BOOL result = [self.sourceImageView drawViewHierarchyInRect:self.targetImageView.bounds afterScreenUpdates:YES];
    
    UIImage *snapshotImage = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    
   if (result)
        self.targetImageView.image = [snapshotImage applyLightEffect];
    else
        NSLog(@&amp;quot;drawViewHierarchyInRect failed&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;ios7-以前截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;iOS7 以前截图&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;- (UIImage *)captureCurrentView:(UIView *)view {
    CGRect frame = view.frame;
    UIGraphicsBeginImageContext(frame.size);
    CGContextRef contextRef = UIGraphicsGetCurrentContext();
    [view.layer renderInContext:contextRef];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
    
    // 获取指定区域的截图
    CGImageRef imageRef = image.CGImage;
    CGRect rect = CGRectMake(0, 0, 300, 300);  //设置指定区域
    CGImageRef editImageRef = CGImageCreateWithImageInRect(imageRef, rect);
    UIImage *editImage = [UIImage alloc] initWithCGImage:editImageRef];
    return editImage;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-uiscorllview-截图:793ee16878053e99cf22e48f2d18d892&#34;&gt;2. UIScorllView 截图&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- (void)screenShot{  
        UIImage *image = nil;         
        UIGraphicsBeginImageContext(_scrollView.contentSize);  
      
        {  
            CGPoint savedContentOffset = _scrollView.contentOffset;  
            CGRect savedFrame = _scrollView.frame;  
            _scrollView.contentOffset = CGPointZero;  
      
            _scrollView.frame = CGRectMake(0, 0, m_scrollView.contentSize.width, m_scrollView.contentSize.height);        
            [_scrollView.layer renderInContext: UIGraphicsGetCurrentContext()];  
      
            image = UIGraphicsGetImageFromCurrentImageContext();       
      
            _scrollView.contentOffset = savedContentOffset;  
            _scrollView.frame = savedFrame;  
        }  
        UIGraphicsEndImageContext();      
      
        if (image != nil) {  
            NSLog(@&amp;quot;success snapshot!&amp;quot;);  
        }  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-截图后拼图:793ee16878053e99cf22e48f2d18d892&#34;&gt;3. 截图后拼图&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;-(void)combinImg:(id)sender
{
    if (self.imgArr.count &amp;lt;=0 ) {
        return;
    }
    NSString *rootPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
 CGFloat tatolHight = self.tableView.contentSize.height +  self.tableView.contentInset.top;
UIGraphicsBeginImageContextWithOptions(CGSizeMake(self.tableView.frame.size.width, tatolHight), NO, 1);    
    CGFloat orgy = 0;
    for(int i = 0; i &amp;lt; self.imgArr.count;i++)
    {
        UIImage *image = (UIImage*)self.imgArr[i];
        [image drawInRect:CGRectMake(0, orgy,image.size.width, image.size.height)];
        orgy += image.size.height;
    }
    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.tableView.frame.size.height )];
    scrollView.contentSize = CGSizeMake(self.view.bounds.size.width, self.tableView.contentSize.height + 64);
    scrollView.backgroundColor = [UIColor brownColor];
    [self.view addSubview:scrollView];
    
    UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 64, scrollView.frame.size.width, self.tableView.contentSize.height)];
    imgView.backgroundColor = [UIColor purpleColor];
    imgView.image = img;
    [scrollView addSubview:imgView];
    
    //写到文件中可打开文件查看
    NSString *path = [rootPath stringByAppendingPathComponent:@&amp;quot;combin.png&amp;quot;];
    NSData *imgData = UIImagePNGRepresentation(img);
    [imgData writeToFile:path atomically:YES];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 多线程锁</title>
      <link>http://felixmlians.github.io/2014/11/17/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</link>
      <pubDate>Mon, 17 Nov 2014 14:01:09 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/11/17/ios-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</guid>
      <description>

&lt;h4 id=&#34;dispatch-semaphore:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;dispatch_semaphore&lt;/h4&gt;

&lt;p&gt;信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），直至计数器大于零，然后线程会减少这个计数。&lt;/p&gt;

&lt;p&gt;在GCD中有三个函数是semaphore的操作，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dispatch_semaphore_create　　　创建一个semaphore&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_signal　　　发送一个信号&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_wait　　　　等待信号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;是发送一个信号，自然会让信号总量加1，&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_t group = dispatch_group_create();   
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);   
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   
    for (int i = 0; i &amp;lt; 100; i++)   
    {   
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   
        dispatch_group_async(group, queue, ^{   
            NSLog(@&amp;quot;%i&amp;quot;,i);   
            sleep(2);   
            dispatch_semaphore_signal(semaphore);   
        });   
    }   
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);   
    dispatch_release(group);   
    dispatch_release(semaphore);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码创建了一个初使值为10的semaphore，每一次for循环都会创建一个新的线程，线程结束的时候会发送一个信号，线程创建之前会信号等待，所以当同时创建了10个线程之后，for循环就会阻塞，等待有线程结束之后会增加一个信号才继续执行，如此就形成了对并发的控制，如上就是一个并发数为10的一个线程队列。&lt;/p&gt;

&lt;h4 id=&#34;pthread-mutex-t:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;pthread_mutex_t&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_NORMAL，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_ERRORCHECK，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果互斥锁类型是 PTHREAD_MUTEX_DEFAULT，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;amp;mutex, NULL);

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;amp;mutex);
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;amp;mutex);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;synchronized:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;@synchronized&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nslock:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
TestObj *obj = [[TestObj alloc] init];
NSLock *lock = [[NSLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;

&lt;h4 id=&#34;nsrecursivelock:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSRecursiveLock&lt;/h4&gt;

&lt;p&gt;NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    static void (^RecursiveMethod)(int);
 
    RecursiveMethod = ^(int value) {
 
        [lock lock];
        if (value &amp;gt; 0) {
 
            NSLog(@&amp;quot;value = %d&amp;quot;, value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };
 
    RecursiveMethod(5);
});
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    sleep(2);
    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];
    if (flag) {
        NSLog(@&amp;quot;lock before date&amp;quot;);
 
        [lock unlock];
    } else {
        NSLog(@&amp;quot;fail to lock before date&amp;quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSRecursiveLock除了实现NSLocking协议的方法外，还提供了两个方法，分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在给定的时间之前去尝试请求一个锁
- (BOOL)lockBeforeDate:(NSDate *)limit
 
// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功
- (BOOL)tryLock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，NSRecursiveLock还声明了一个name属性，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property(copy) NSString *name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用这个字符串来标识一个锁。Cocoa也会使用这个name作为错误描述信息的一部分。&lt;/p&gt;

&lt;h4 id=&#34;nscondition:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSCondition&lt;/h4&gt;

&lt;p&gt;使用NSCondition，实现多线程的同步，即，可实现生产者消费者问题。&lt;/p&gt;

&lt;p&gt;基本思路是，首先要创建公用的NSCondition实例。然后：&lt;/p&gt;

&lt;p&gt;消费者取得锁，取产品，如果没有，则wait，这时会释放锁，直到有线程唤醒它去消费产品；&lt;/p&gt;

&lt;p&gt;生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)conditionTest:(id)sender
{
    NSLog(@&amp;quot;begin condition works!&amp;quot;);
    products = [[NSMutableArray alloc] init];
    condition = [[NSCondition alloc] init];
     
    [NSThread detachNewThreadSelector:@selector(createProducter) toTarget:self withObject:nil];
    [NSThread detachNewThreadSelector:@selector(createConsumenr) toTarget:self withObject:nil];
}
 
- (void)createConsumenr
{
    [condition lock];
    while ([products count] == 0) {
        NSLog(@&amp;quot;wait for products&amp;quot;);
        [condition wait];
    }
    [products removeObjectAtIndex:0];
    NSLog(@&amp;quot;comsume a product&amp;quot;);
    [condition unlock];
}
 
- (void)createProducter
{
    [condition lock];
    [products addObject:[[NSObject alloc] init]];
    NSLog(@&amp;quot;produce a product&amp;quot;);
    [condition signal];
    [condition unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsconditionlock:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSConditionLock&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//主线程中
NSConditionLock *theLock = [[NSConditionLock alloc] init];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    for (int i=0;i&amp;lt;=2;i++)
    {
        [theLock lock];
        NSLog(@&amp;quot;thread1:%d&amp;quot;,i);
        sleep(2);
        [theLock unlockWithCondition:i];
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [theLock lockWhenCondition:2];
    NSLog(@&amp;quot;thread2&amp;quot;);
    [theLock unlock];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nsdistributedlock-分布式锁:e5e34ac17f1991e31b78fbf65ec79a34&#34;&gt;NSDistributedLock 分布式锁&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>SQLite（简介）</title>
      <link>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 22 Oct 2014 17:27:18 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/10/22/sqlite%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;p&gt;SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。
就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。&lt;/p&gt;

&lt;p&gt;所有教程参考地址： &lt;a href=&#34;http://www.runoob.com/sqlite/sqlite-intro.html&#34;&gt;http://www.runoob.com/sqlite/sqlite-intro.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：&lt;/p&gt;

&lt;h4 id=&#34;ddl-数据定义语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DDL - 数据定义语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;CREATE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一个新的表，一个表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ALTE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改数据库中的某个已有的数据库对象，比如一个表。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DROP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除整个表，或者表的视图，或者数据库中的其他对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dml-数据操作语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DML - 数据操作语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;INSERT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;创建一条记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;UPDAT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DELETE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;dql-数据查询语言:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;DQL - 数据查询语言&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SELECT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从一个或多个表中检索某些记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;在-mac-os-x-上安装-sqlite:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;在 Mac OS X 上安装 SQLite&lt;/h4&gt;

&lt;p&gt;最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请访问 SQLite 下载页面，从源代码区下载 sqlite-autoconf-*.tar.gz。&lt;/li&gt;
&lt;li&gt;步骤如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	$tar xvfz sqlite-autoconf-3071502.tar.gz
	$cd sqlite-autoconf-3071502
	$./configure --prefix=/usr/local
	$make
	$make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sqlite3
SQLite version 3.7.15.2 2013-01-09 11:53:05
Enter &amp;quot;.help&amp;quot; for instructions
Enter SQL statements terminated with a &amp;quot;;&amp;quot;
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-命令-1:e19fbb7c7f34431d5d6c598ccca191ea&#34;&gt;SQLite 命令&lt;/h4&gt;

&lt;p&gt;获取可用的点命令的清单，可以在任何时候输入 &amp;ldquo;.help&amp;rdquo;。&lt;code&gt;sqlite&amp;gt;.help&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 .show 命令，来查看 SQLite 命令提示符的默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.show
     echo: off
  explain: off
  headers: off
     mode: column
nullvalue: &amp;quot;&amp;quot;
   output: stdout
separator: &amp;quot;|&amp;quot;
    width:
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;确保 sqlite&amp;gt; 提示符与点命令之间没有空格，否则将无法正常工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用下列的点命令来格式化输出为本教程下面所列出的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.header on
sqlite&amp;gt;.mode column
sqlite&amp;gt;.timer on
sqlite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面设置将产生如下格式的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID          NAME        AGE         ADDRESS     SALARY
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0
2           Allen       25          Texas       15000.0
3           Teddy       23          Norway      20000.0
4           Mark        25          Rich-Mond   65000.0
5           David       27          Texas       85000.0
6           Kim         22          South-Hall  45000.0
7           James       24          Houston     10000.0
CPU Time: user 0.000000 sys 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主表中保存数据库表的关键信息，并把它命名为 sqlite_master。如要查看表概要，可按如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite&amp;gt;.schema sqlite_master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将产生如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE sqlite_master (
  type text,
  name text,
  tbl_name text,
  rootpage integer,
  sql text
);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS HTTP Multipart Forms POST(头像图片上传)</title>
      <link>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</link>
      <pubDate>Sat, 13 Sep 2014 12:49:42 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/09/13/ios-http-multipart-forms-post%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</guid>
      <description>&lt;p&gt;由于iOS无法通过html表单来上传图片，因此想要上传图片，必须实现http请求，而不能像其他语言那样通过html表单的post就能上传。&lt;/p&gt;

&lt;p&gt;上传图片的http post请求的格式是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-type: multipart/form-data, boundary=---------------------------14737809831466499882746641449

---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.jpg&amp;quot;
Content-Type: image/jpeg

... contents of boo,jpg ...
---------------------------14737809831466499882746641449
Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
---------------------------14737809831466499882746641449
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行是指定了&lt;code&gt;http post&lt;/code&gt;请求的编码方式为&lt;code&gt;multipart/form-data&lt;/code&gt;（上传文件必须用这个）。
&lt;code&gt;boundary= xxx&lt;/code&gt; 说明了&lt;code&gt;xxx&lt;/code&gt;为分界线。比如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt; 就是一个分界线的意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Disposition: form-data; name=&amp;quot;info&amp;quot;

Hello Boris!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话声明了请求中的一个字段的名称，如&lt;code&gt;info&lt;/code&gt;  以及字段的值，如&lt;code&gt;Hello Boris!&lt;/code&gt;
这里类似&lt;code&gt;form&lt;/code&gt;表单中的&lt;code&gt;&amp;lt;input name=&amp;quot;info&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;Hello Boris!&amp;quot;/&amp;gt;&lt;/code&gt;
中间的空行是必须的。&lt;/p&gt;

&lt;p&gt;不同的字段之间用分界线分开，分界线需要单独一行，如 &lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分界线的下一行，是下一个字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;content-disposition: form-data; name=&amp;quot;pic&amp;quot;; filename=&amp;quot;boo.png&amp;quot;
Content-Type: image/png

... contents of boo.png ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里声明了变量&lt;code&gt;pic&lt;/code&gt;，也就是我们要传的文件，上传文件的时候需要在后边指定&lt;code&gt;file name：filename=&amp;quot;boo.png&amp;quot;&lt;/code&gt;
并且需要在下一行指定文件的格式：&lt;code&gt;Content-Type: image/png&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;... contents of boo.png ...&lt;/code&gt;  这里是&lt;code&gt;boo.png&lt;/code&gt;的二进制内容，如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;89504e47 0d0a1a0a 0000000d 49484452 000000b4 000000b4 08020000 00b2af91 65000020 00494441 5478012c dd79b724 6b7616f6 8c888c88 8c9c8733 55ddb1d5 6a0db486 06218401 ......&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在http post请求的结尾，需要有一个分界线，但是是前后都有&amp;ndash;的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;---------------------------14737809831466499882746641449&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上的这些格式，是http的规范，每个空行，空格都是必须的。&lt;/p&gt;

&lt;p&gt;下边是iOS的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 建立请求对象
NSMutableURLRequest * request = [[NSMutableURLRequest alloc] init];
[request setURL:[NSURL URLWithString:kRequestBaseApi]];

// 请求方式
[request setHTTPMethod:@&amp;quot;POST&amp;quot;];
[request setTimeoutInterval:kCLTimeoutInterval];

// 接口参数
NSString *string = [NSString stringWithFormat:@&amp;quot;{\&amp;quot;action\&amp;quot;:\&amp;quot;saveHeadImg\&amp;quot;,\&amp;quot;uid\&amp;quot;:\&amp;quot;%@\&amp;quot;}&amp;quot;, [ClientState shareInstance].currentUID];

// 头标签，分隔线
NSString *boundary = @&amp;quot;---------------------------14737809831466499882746641449&amp;quot;;
NSString *contentType = [NSString stringWithFormat:@&amp;quot;multipart/form-data; boundary=%@&amp;quot;,boundary];
[request addValue:contentType forHTTPHeaderField: @&amp;quot;Content-Type&amp;quot;];

NSMutableData *body = [NSMutableData data];

// 添加接口参数
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;req\&amp;quot;\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;%@\r\n&amp;quot;,string] dataUsingEncoding:NSUTF8StringEncoding]];

// 添加图片data
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[[NSString stringWithFormat:@&amp;quot;Content-Disposition: form-data; name=\&amp;quot;files\&amp;quot;; filename=\&amp;quot;%@\&amp;quot;\r\n&amp;quot;, fileName]
                  dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[@&amp;quot;Content-Type: image/pjpeg\r\n\r\n&amp;quot; dataUsingEncoding:NSUTF8StringEncoding]];
[body appendData:[NSData dataWithData:imageData]];

// 添加尾部分隔线
[body appendData:[[NSString stringWithFormat:@&amp;quot;\r\n--%@--\r\n&amp;quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]];
[request setHTTPBody:body];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于宏</title>
      <link>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</link>
      <pubDate>Sat, 09 Aug 2014 11:38:21 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/08/09/%E5%85%B3%E4%BA%8E%E5%AE%8F/</guid>
      <description>

&lt;p&gt;C中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)。对于对象宏来说确实相对简单，但却也不是那么简单的查找替换。对象宏一般用来定义一些常数，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define M_PI    3.14159265358979323846264338327950288
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;关键字表明即将开始定义一个宏，紧接着的&lt;code&gt;M_PI&lt;/code&gt;是宏的名字，空格之后的数字是内容。类似这样的&lt;code&gt;#define X A&lt;/code&gt;的宏是比较简单的，在编译时编译器会在语义分析认定是宏后，将X替换为A，这个过程称为宏的展开。比如对于上面的&lt;code&gt;M_PI&lt;/code&gt;直接使用。&lt;/p&gt;

&lt;p&gt;函数宏顾名思义，就是行为类似函数，可以接受参数的宏。具体来说，在定义的时候，如果我们在宏名字后面跟上一对括号的话，这个宏就变成了函数宏。从最简单的例子开始，比如下面这个函数宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DES(x)  x
NSString *name = @&amp;quot;Macro Rookie&amp;quot;;  
NSLog(@&amp;quot;Hello %@&amp;quot;,DES(name));  
// =&amp;gt; NSLog(@&amp;quot;Hello %@&amp;quot;,name);
//   =&amp;gt; Hello Macro Rookie 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏做的事情是，在编译时如果遇到&lt;code&gt;DES&lt;/code&gt;，并且后面带括号，并且括号中的参数个数与定义的相符，那么就将括号中的参数换到定义的内容里去，然后替换掉原来的内容。 具体到这段代码中，&lt;code&gt;DES&lt;/code&gt;接受了一个&lt;code&gt;name&lt;/code&gt;，然后将整个&lt;code&gt;DES(name)&lt;/code&gt;用&lt;code&gt;name&lt;/code&gt;替换掉。多个参数的宏例如这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PLUS(x,y) (x + y)
printf(&amp;quot;%d&amp;quot;,PLUS(3,2));  
// =&amp;gt; printf(&amp;quot;%d&amp;quot;,3 + 2);
//  =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;因为宏展开其实是编辑器的预处理，因此它可以在更高层级上控制程序源码本身和编译流程。而正是这个特点，赋予了宏很强大的功能和灵活度。但是凡事都有两面性，在获取灵活的背后，是以需要大量时间投入以对各种边界情况进行考虑来作为代价的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#define __NSX_PASTE__(A,B) A##B

#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)

#define __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); \
                                 __typeof__(B) __NSX_PASTE__(__b,L) = (B); \
                                (__NSX_PASTE__(__a,L) &amp;lt; __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); \
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;MIN&lt;/code&gt;一共由三个宏定义组合而成。第一个&lt;code&gt;__NSX_PASTE__&lt;/code&gt;里出现的两个连着的井号&lt;code&gt;##&lt;/code&gt;在宏中是一个特殊符号，它表示将两个参数连接起来这种运算。注意函数宏必须是有意义的运算，因此你不能直接写&lt;code&gt;AB&lt;/code&gt;来连接两个参数，而需要写成例子中的&lt;code&gt;A##B&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来是我们调用的两个参数的&lt;code&gt;MIN&lt;/code&gt;，它做的事是调用了另一个三个参数的宏&lt;code&gt;__NSMIN_IMPL__&lt;/code&gt;，其中前两个参数就是我们的输入，而第三个&lt;code&gt;__COUNTER__&lt;/code&gt;是一个预定义的宏，这个值在编译过程中将从&lt;code&gt;0&lt;/code&gt;开始计数，每次被调用时加&lt;code&gt;1&lt;/code&gt;。因为唯一性，所以很多时候被用来构造独立的变量名称。有了上面的基础，再来看最后的实现宏就很简单了。整体思路和前面的实现和之前的GNUC MIN是一样的，区别在于为变量名&lt;code&gt;__a&lt;/code&gt;和&lt;code&gt;__b&lt;/code&gt;添加了一个计数后缀，这样大大避免了变量名相同而导致问题的可能性。&lt;/p&gt;

&lt;h3 id=&#34;log:88505ded347af25f6a47875a4eb189b9&#34;&gt;Log&lt;/h3&gt;

&lt;p&gt;我们通过宏，可以很简单地完成对NSLog原生行为的改进，优雅，高效。只需要在预编译的pch文件中加上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//A better version of NSLog
#define NSLog(format, ...) do {  \
                              fprintf(stderr, &amp;quot;&amp;lt;%s : %d&amp;gt; %s\n&amp;quot;,   \
                              [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \
                              __LINE__, __func__);\
                              (NSLog)((format), ##__VA_ARGS__);   \
                              fprintf(stderr, &amp;quot;-------\n&amp;quot;);   \
                             } while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是定义部分，第2行的&lt;code&gt;NSLog(format, ...)&lt;/code&gt;。我们看到的是一个函数宏，但是它的参数比较奇怪，第二个参数是&lt;code&gt;...&lt;/code&gt;，在宏定义（其实也包括函数定义）的时候，写为&lt;code&gt;...&lt;/code&gt;的参数被叫做可变参数(variadic)。可变参数的个数不做限定。在这个宏定义中，除了第一个参数format将被单独处理外，接下来输入的参数将作为整体一并看待。回想一下NSLog的用法，我们在使用NSLog时，往往是先给一个format字符串作为第一个参数，然后根据定义的格式在后面的参数里跟上写要输出的变量之类的。这里第一个格式化字符串即对应宏里的format，后面的变量全部映射为&lt;code&gt;...&lt;/code&gt;作为整体处理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__FILE__&lt;/code&gt;返回当前文件的绝对路径，&lt;code&gt;__LINE__&lt;/code&gt;返回展开该宏时在文件中的行数，&lt;code&gt;__func__&lt;/code&gt;是改宏所在scope的函数名称。我们在做Log输出时如果带上这这三个参数，便可以加快解读Log，迅速定位。关于编译器预定义的Log以及它们的一些实现机制，感兴趣的同学可以移步到gcc文档的PreDefine页面和clang的Builtin Macro进行查看。在这里我们将格式化输出的三个参数分别设定为文件名的最后一个部分（因为绝对路径太长很难看），行数，以及方法名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define NSLogRect(rect) NSLog(@&amp;quot;%s x:%.4f, y:%.4f, w:%.4f, h:%.4f&amp;quot;, #rect, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)
#define NSLogSize(size) NSLog(@&amp;quot;%s w:%.4f, h:%.4f&amp;quot;, #size, size.width, size.height)
#define NSLogPoint(point) NSLog(@&amp;quot;%s x:%.4f, y:%.4f&amp;quot;, #point, point.x, point.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;宏:88505ded347af25f6a47875a4eb189b9&#34;&gt;宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//获取系统版本  
#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]  
#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion]  

//获取当前语言  
#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])  

//判断是否 Retina屏、设备是否%fhone 5、是否是iPad  
#define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)  
#define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO)  
#define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)     

// rgb颜色转换（16进制-&amp;gt;10进制）  
#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16))/255.0 green:((float)((rgbValue &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8))/255.0 blue:((float)(rgbValue &amp;amp; 0xFF))/255.0 alpha:1.0]  

//带有RGBA的颜色设置  
#define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]  

// 获取RGB颜色  
#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]  
#define RGB(r,g,b) RGBA(r,g,b,1.0f)

  //由角度获取弧度 有弧度获取角度  
#define degreesToRadian(x) (M_PI * (x) / 180.0)  
#define radianToDegrees(radian) (radian*180.0)/(M_PI)  

#define DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, onceBlock);

DISPATCH_ONCE_BLOCK(^{
//code
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于FMDB/SQLite</title>
      <link>http://felixmlians.github.io/2014/07/18/%E5%85%B3%E4%BA%8Efmdb/sqlite/</link>
      <pubDate>Fri, 18 Jul 2014 21:35:38 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/07/18/%E5%85%B3%E4%BA%8Efmdb/sqlite/</guid>
      <description>

&lt;p&gt;到&lt;a href=&#34;https://github.com/ccgus/fmdb&#34;&gt;https://github.com/ccgus/fmdb&lt;/a&gt; 下载源文件，然后直接将fmdb文件夹拖入到你的工程就OK。
当然你需要添加依赖库：libsqlite3.dylib&lt;/p&gt;

&lt;p&gt;拖入源文件，并且添加依赖库以后你就可以使用FMDB了，引用头文件
&lt;code&gt;#import &amp;quot;FMDB.h&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;USAGE&lt;/h2&gt;

&lt;p&gt;在FMDB中主要有三个类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;FMDatabase - 简单的说这个类就是代表了数据库&lt;/li&gt;
&lt;li&gt;FMResultSet - 这个类表示查询操作的结果&lt;/li&gt;
&lt;li&gt;FMDatabaseQueue - 多线程操作的时候你会用到这个类，并且这是线程安全的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;创建数据库:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;创建数据库&lt;/h3&gt;

&lt;p&gt;你需要使用一个path来创建一个本地FMDatabase数据库，这个path有三种类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以使用一个本地的地址来创建这个数据库，这个地址不一定真实存在，如果不存在，那么FMDB会创建这个数据库并返回，存在则直接返回这个数据库。&lt;/li&gt;
&lt;li&gt;一个空字符串@&amp;ldquo;&amp;rdquo;.FMDB会在本地创建一个临时的数据库，当数据库关闭的时候会删除这个数据库。&lt;/li&gt;
&lt;li&gt;NULL.如果你将这个path填的是NULL，那么这个数据被创建在内存中，数据库关闭的时候被销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(更多信息关于临时数据库和在内存中的数据库，你可以阅读这篇文档 &lt;a href=&#34;http://www.sqlite.org/inmemorydb.html&#34;&gt;http://www.sqlite.org/inmemorydb.html&lt;/a&gt; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMDatabase *db = [FMDatabase databaseWithPath:@&amp;quot;/tmp/tmp.db&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;打开数据库:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;打开数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (![db open]) {
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;executing-updates:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Executing Updates&lt;/h3&gt;

&lt;p&gt;所有不是select操作的操作都算update. 包括 CREATE, UPDATE, INSERT, ALTER, COMMIT, BEGIN, DETACH, DELETE, DROP, END, EXPLAIN, VACUUM, and REPLACE ····换句话说也就是如果你的操作不是以SELECT开头的都是update操作.&lt;/p&gt;

&lt;p&gt;update操作返回一个布尔值，YES表示操作成功，NO表示你可以遇到了一些错误.FMDatabase有两个方法 -lastErrorMessage 和 -lastErrorCode，你可以使用这两个方法来查看错误。&lt;/p&gt;

&lt;h3 id=&#34;executing-queries:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Executing Queries&lt;/h3&gt;

&lt;p&gt;SELECT 查询使用 -executeQuery&amp;hellip; 方法.&lt;/p&gt;

&lt;p&gt;查询成功返回 FMResultSet,失败则是返回nil.
同样你可以使用FMDatabase的两个方法 -lastErrorMessage and -lastErrorCode 来查找原因。&lt;/p&gt;

&lt;p&gt;你需要用一个循环来获取到查询到的每一个值。like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMResultSet *s = [db executeQuery:@&amp;quot;SELECT * FROM myTable&amp;quot;];
while ([s next]) {
    //retrieve values for each record
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FMResultSet 有许多类型用来返回不同类型的查询结果的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;intForColumn:
longForColumn:
longLongIntForColumn:
boolForColumn:
doubleForColumn:
stringForColumn:
dateForColumn:
dataForColumn:
dataNoCopyForColumn:
UTF8StringForColumnName:
objectForColumnName:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的每个方法都有对应的 {type}ForColumnIndex: 上面那一溜方法是用例的名字来获取数据，而这个方法则是用数据在查询结果中对应的位置来获取数据.&lt;/p&gt;

&lt;h3 id=&#34;closing:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;Closing&lt;/h3&gt;

&lt;p&gt;用完了FMDB记得关闭&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[db close];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;批处理:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;批处理&lt;/h3&gt;

&lt;p&gt;FMDatabase的方法 executeStatements:withResultBlock:可以使用字符串来同时处理多条指令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *sql = @&amp;quot;create table test1 (id integer primary key autoincrement, x text);&amp;quot;
                 &amp;quot;create table test2 (id integer primary key autoincrement, y text);&amp;quot;
                 &amp;quot;create table test3 (id integer primary key autoincrement, z text);&amp;quot;
                 &amp;quot;insert into test1 (x) values (&#39;XXX&#39;);&amp;quot;
                 &amp;quot;insert into test2 (y) values (&#39;YYY&#39;);&amp;quot;
                 &amp;quot;insert into test3 (z) values (&#39;ZZZ&#39;);&amp;quot;;

success = [db executeStatements:sql];

sql = @&amp;quot;select count(*) as count from test1;&amp;quot;
       &amp;quot;select count(*) as count from test2;&amp;quot;
       &amp;quot;select count(*) as count from test3;&amp;quot;;

success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) {
    NSInteger count = [dictionary[@&amp;quot;count&amp;quot;] integerValue];
    XCTAssertEqual(count, 1, @&amp;quot;expected one record for dictionary %@&amp;quot;, dictionary);
    return 0;
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据处理:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;数据处理&lt;/h3&gt;

&lt;p&gt;你必须使用标准的SQLite的标准语法，像下面那样（而不是SQL中那样）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO myTable VALUES (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘？’这个符号表示插入数据的替代符，操作方法会接收参数来替代这个符号 (或者是代表这些参数的，比如说：NSArray, NSDictionary, va_list).&lt;/p&gt;

&lt;p&gt;OC中你可以像下面这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSInteger identifier = 42;
NSString *name = @&amp;quot;Liam O&#39;Flaherty (\&amp;quot;the famous Irish author\&amp;quot;)&amp;quot;;
NSDate *date = [NSDate date];
NSString *comment = nil;

BOOL success = [db executeUpdate:@&amp;quot;INSERT INTO authors (identifier, name, date, comment) VALUES (?, ?, ?, ?)&amp;quot;, @(identifier), name, date, comment ?: [NSNull null]];
if (!success) {
NSLog(@&amp;quot;error = %@&amp;quot;, [db lastErrorMessage]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note:这里需要注意的是，如果是基本数据类型比如说&lt;code&gt;NSInteger&lt;/code&gt;，你需要转化为&lt;code&gt;NSNumber&lt;/code&gt;。
如果是插入nil，那么你不能直接插入nil，而是需要插入&lt;code&gt;[NSNull null]&lt;/code&gt;，像上面那个例子中写的是：&lt;code&gt;comment ?: [NSNull null]&lt;/code&gt;，那么如果commit是nil的话则会插入nil，反之则会插入commit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这种书写方法和上面表达的是同一个意思。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO authors (identifier, name, date, comment) VALUES (:identifier, :name, :date, :comment)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像上面这种写法参数是以冒号开头的，SQLite支持其他字符，但是在字典中key都是以冒号为前缀的，所以你的字典key中不要包含冒号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSDictionary *arguments = @{@&amp;quot;identifier&amp;quot;: @(identifier), @&amp;quot;name&amp;quot;: name, @&amp;quot;date&amp;quot;: date, @&amp;quot;comment&amp;quot;: comment ?: [NSNull null]};
BOOL success = [db executeUpdate:@&amp;quot;INSERT INTO authors (identifier, name, date, comment) VALUES (:identifier, :name, :date, :comment)&amp;quot; withParameterDictionary:arguments];
if (!success) {
NSLog(@&amp;quot;error = %@&amp;quot;, [db lastErrorMessage]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最关键的一点就是：千万不要用NSString的方法比如说 stringWithFormat来手动插入参数，必须要使用Values(?，?)这样的方法，把？当作替代符。&lt;/p&gt;

&lt;h3 id=&#34;fmdatabasequeue-是线程安全的:1669b6fc6448a969ff9f21fb62406e06&#34;&gt;FMDatabaseQueue 是线程安全的&lt;/h3&gt;

&lt;p&gt;不要在多个线程之间使用同一个 FMDatabase对象，最好是每一个线程都有一个独立的 FMDatabase对象，如果你在多线程之间使用同一个对象，那么会有不好的事情发生。
如果你需要在多线程中使用 FMDatabase,那么请使用 FMDatabaseQueue，下面是他的使用方法:&lt;/p&gt;

&lt;p&gt;首先创建你的线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，像这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[queue inDatabase:^(FMDatabase *db) {
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @1];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @2];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @3];

FMResultSet *rs = [db executeQuery:@&amp;quot;select * from foo&amp;quot;];
while ([rs next]) {
    …
}
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An easy way to wrap things up in a transaction can be done like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[queue inTransaction:^(FMDatabase *db, BOOL *rollback) {
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @1];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @2];
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @3];

if (whoopsSomethingWrongHappened) {
    *rollback = YES;
    return;
}
// etc…
[db executeUpdate:@&amp;quot;INSERT INTO myTable VALUES (?)&amp;quot;, @4];
}];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSNotification 通知</title>
      <link>http://felixmlians.github.io/2014/07/03/nsnotification-%E9%80%9A%E7%9F%A5/</link>
      <pubDate>Thu, 03 Jul 2014 18:56:41 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/07/03/nsnotification-%E9%80%9A%E7%9F%A5/</guid>
      <description>

&lt;p&gt;NSNotification 一个对象通知另外一个对象，可以用来传递参数、通信等作用，与delegate的一对一不同，通知是一对多的。在一个对象中注册了通知，那么其他任意对象都可以来对这个对象发出通知。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSNotificationCenter&lt;/li&gt;
&lt;li&gt;NSNotificationQueue&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nsnotificationcenter:cd29d22e126672704ff5fec0205d1cc7&#34;&gt;NSNotificationCenter&lt;/h3&gt;

&lt;p&gt;注册一个通知：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self  
                                         selector:@selector(getNotification:) 
                                             name:@&amp;quot;notificationMethon&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NSNorificationCenter是一个单例，我们可以通过defaultCenter来获取到通知中心这个单例；&lt;/p&gt;

&lt;p&gt;需要注意的是当我们添加一个通知以后，必须在合适的位置将通知移除，不然下次再添加这个通知并调用时，这个通知将会被调用多次，而这一般不是我们所预料的。一般我们在对象的析构函数中将通知移除，我们可以选择将这个对象中的所有通知移除，也可以选择一个一个按照通知的name来移除。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] removeObserver:self];

[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;notificationMethon&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发出通知就是通过 &lt;code&gt;postNotificationName&lt;/code&gt; 函数来实现，这里发出的通知是同步操作，也就是只有当发出的通知执行完成后才会继续执行下面的代码。&lt;/p&gt;

&lt;p&gt;这是发出通知以后会调用的方法，在多线程操作时，发出通知的对象和接收通知的对象处于同一个线程。
在这个响应的方法中有一个参数(NSNotification *)info这个参数是NSNotification类型的，这个类型有几个属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (readonly, copy) NSString *name;
@property (nullable, readonly, retain) id object;
@property (nullable, readonly, copy) NSDictionary *userInfo;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nsnotificationqueue:cd29d22e126672704ff5fec0205d1cc7&#34;&gt;NSNotificationQueue&lt;/h3&gt;

&lt;p&gt;NSNotificationQueue就有一些区别，他有两个非常重要的特点：即通告的聚结和异步发送。聚结是把和刚进入队列的通告相类似的其它通告从队列中移除的过程。如果一个新的通告和已经在队列中的通告相类似，则新的通告不进入队列，而所有类似的通告（除了队列中的第一个通告以外）都被移除。然而，您不应该依赖于这个特殊的聚结行为。
而异步发送则很好理解了，也就是说发出通知以后立刻返回，也就是是继续执行下面的代码，并不管通知发出后的具体情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSNotification *notifacation = [[NSNotification alloc]initWithName:@&amp;quot;notificationName&amp;quot; object:nil userInfo:@{@&amp;quot;key1&amp;quot;:@&amp;quot;value1&amp;quot;}];
[[NSNotificationQueue defaultQueue] enqueueNotification:notifacation postingStyle:NSPostWhenIdle];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过，NSNotificationQueue的defaultQueue来获取到这个通知队列，然后调用enqueueNotification来发出通知，我们可以看到第二个参数postingStyle,这个参数是一个枚举，他可以是以下三个值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef NS_ENUM(NSUInteger, NSPostingStyle) {
    NSPostWhenIdle = 1,
    NSPostASAP = 2,
    NSPostNow = 3
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个不同的值是有一定区别的。（以下内容摘抄自网络）&lt;/p&gt;

&lt;p&gt;尽快发送
以NSPostASAP风格进入队列的通告会在运行循环的当前迭代完成时被发送给通告中心，如果当前运行循环模式和请求的模式相匹配的话（如果请求的模式和当前模式不同，则通告在进入请求的模式时被发出）。由于运行循环在每个迭代过程中可能进行多个调用分支（callout），所以在当前调用分支退出及控制权返回运行循环时，通告可能被分发，也可能不被分发。其它的调用分支可能先发生，比如定时器或由其它源触发了事件，或者其它异步的通告被分发了。&lt;/p&gt;

&lt;p&gt;您通常可以将NSPostASAP风格用于开销昂贵的资源，比如显示服务器。如果在运行循环的一个调用分支过程中有很多客户代码在窗口缓冲区中进行描画，在每次描画之后将缓冲区的内容刷新到显示服务器的开销是很昂贵的。在这种情况下，每个draw&amp;hellip;方法都会将诸如“FlushTheServer” 这样的通告排入队列，并指定按名称和对象进行聚结，以及使用NSPostASAP风格。结果，在运行循环的最后，那些通告中只有一个被派发，而窗口缓冲区也只被刷新一次。&lt;/p&gt;

&lt;p&gt;空闲时发送
以NSPostWhenIdle风格进入队列的通告只在运行循环处于等待状态时才被发出。在这种状态下，运行循环的输入通道中没有任何事件，包括定时器和异步事件。以NSPostWhenIdle风格进入队列的一个典型的例子是当用户键入文本、而程序的其它地方需要显示文本字节长度的时候。在用户输入每一个字符后都对文本输入框的尺寸进行更新的开销是很大的（而且不是特别有用），特别是当用户快速输入的时候。在这种情况下，Cocoa会在每个字符键入之后，将诸如“ChangeTheDisplayedSize”这样的通告进行排队，同时把聚结开关打开，并使用NSPostWhenIdle风格。当用户停止输入的时候，队列中只有一个“ChangeTheDisplayedSize”通告（由于聚结的原因）会在运行循环进入等待状态时被发出，显示部分也因此被刷新。请注意，运行循环即将退出（当所有的输入通道都过时的时候，会发生这种情况）时并不处于等待状态，因此也不会发出通告。&lt;/p&gt;

&lt;p&gt;立即发送
以NSPostNow风格进入队列的通告会在聚结之后，立即发送到通告中心。您可以在不需要异步调用行为的时候 使用NSPostNow风格（或者通过NSNotificationCenter的postNotification:方法来发送）。在很多编程环境下，我们不仅允许同步的行为，而且希望使用这种行为：即您希望通告中心在通告派发之后返回，以便确定观察者对象收到通告并进行了处理。当然，当您希望通过聚结移除队列中类似的通告时，应该用enqueueNotification&amp;hellip;方法，且使用NSPostNow风格，而不是使用postNotification:方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有关block</title>
      <link>http://felixmlians.github.io/2014/06/29/%E6%9C%89%E5%85%B3block/</link>
      <pubDate>Sun, 29 Jun 2014 20:36:29 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/29/%E6%9C%89%E5%85%B3block/</guid>
      <description>

&lt;h4 id=&#34;block发生引用循环:cc738f5dd4a4ad7b4748fcc0c94d63e1&#34;&gt;block发生引用循环&lt;/h4&gt;

&lt;p&gt;一个对象中强引用了block，在block中又使用了该对象，就会发生循环引用。解决方法就是将该对象使用 &lt;code&gt;__weak&lt;/code&gt;或者 &lt;code&gt;__block&lt;/code&gt; 修饰符修饰后在block中使用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;id weak weakSelf = self&lt;/code&gt;, 或者 &lt;code&gt;weak __typeof(&amp;amp;*self)weakSelf = self&lt;/code&gt; (可以将该方法设置为宏）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id __block weakSelf = self&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;在block内修改block外部变量:cc738f5dd4a4ad7b4748fcc0c94d63e1&#34;&gt;在block内修改block外部变量&lt;/h4&gt;

&lt;p&gt;默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 &lt;code&gt;__block&lt;/code&gt; 来让其写操作生效；&lt;/p&gt;

&lt;h4 id=&#34;使用系统的某些block-api的引用循环问题:cc738f5dd4a4ad7b4748fcc0c94d63e1&#34;&gt;使用系统的某些block api的引用循环问题&lt;/h4&gt;

&lt;p&gt;系统的block api中，UIView的block版本写动画时不需要考虑。&lt;/p&gt;

&lt;p&gt;所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block强引用 self）没有问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; 

[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.property = foo; }]; 

[[NSNotificationCenter defaultCenter] addObserverForName:@&amp;quot;cl_Notification&amp;quot; 
                                                  object:nil 
                           queue:[NSOperationQueue mainQueue]
                                              usingBlock:^(NSNotification * notification) {
                                                    self.property = boo; }]; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你使用了一些参数中可能含有ivar的体统api，如GCD、 NSNotificationCenter就要小心。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__weak __typeof__(self) weakSelf = self;
dispatch_group_async(_operationsGroup, _operationsQueue, ^
{
__typeof__(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doSomethingElse];
} );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; __weak __typeof__(self) weakSelf = self;
  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&amp;quot;testKey&amp;quot;
                                                                object:nil
                                                                 queue:nil
                                                            usingBlock:^(NSNotification *note) {
      __typeof__(self) strongSelf = weakSelf;
      [strongSelf dismissModalViewControllerAnimated:YES];
  }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;self&amp;ndash;&amp;gt; _observer &amp;ndash;&amp;gt; block &amp;ndash;&amp;gt; self&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>runloop 简介</title>
      <link>http://felixmlians.github.io/2014/06/26/runloop-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Jun 2014 19:49:43 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/26/runloop-%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;h4 id=&#34;runloop-和线程有什么关系:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop 和线程有什么关系？&lt;/h4&gt;

&lt;p&gt;总的来说，Runloop,如其名，表示着一直在运行的循环。实际上，runloop和线程是紧密相连的，可以这样说runloop是为了线程而生，没有线程，它就没有存在的必要。每个线程，包括程序的主线程（main thread)都有与之对应的runloop对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主线程的runloop默认是启动的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;iOS的应用程序里面，程序启动后会有一个如下的 &lt;code&gt;main()&lt;/code&gt; 函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了，为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对其他线程来说，runloop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在任何一个cocoa程序的线程中，都可以通过以下代码来获取到当前的runloop。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;    NSRunLoop *runloop = [NSRunLoop currentRunLoop];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;runloop的mode主要来指定事件在运行中的优先级:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop的mode主要来指定事件在运行中的优先级&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态&lt;/li&gt;
&lt;li&gt;UITrackingRunLoopMode：ScrollView滑动时&lt;/li&gt;
&lt;li&gt;UIInitializationRunLoopMode：启动时&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;苹果公开提供的 Mode 有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;runloop-只能运行在一中mode-中:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop 只能运行在一中mode 中&lt;/h4&gt;

&lt;p&gt;RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。&lt;/p&gt;

&lt;p&gt;如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。&lt;/p&gt;

&lt;p&gt;同时因为mode还是可定制的，所以：&lt;/p&gt;

&lt;p&gt;Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将timer添加到NSDefaultRunLoopMode中
[NSTimer scheduledTimerWithTimeInterval:1.0
                                 target:self
                               selector:@selector(timerTick:)
                               userInfo:nil
                                repeats:YES];
//然后再添加到NSRunLoopCommonModes里
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0
                                         target:self
                                       selector:@selector(timerTick:)
                                       userInfo:nil
                                        repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;runloop内部实现:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;runloop内部实现&lt;/h4&gt;

&lt;p&gt;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但不退出，通常的代码逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;objc-管理对象内存:1bd331b533e8f261b2d2d1994da9040c&#34;&gt;objc 管理对象内存&lt;/h4&gt;

&lt;p&gt;通过retainCount 的机制来决定对象是否需要释放。每次runloop的时候，都会检查对象的retainCount，如果retainCount为0，说明该对象没有地方需要继续使用了，可以释放掉了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>类中增加实例变量</title>
      <link>http://felixmlians.github.io/2014/06/23/%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 23 Jun 2014 18:34:54 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/23/%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</guid>
      <description>

&lt;h4 id=&#34;能否向编译后得到的类中增加实例变量-能否向运行时创建的类中增加实例变量:e95b6352016c71c7e0e43fef78963e01&#34;&gt;能否向编译后得到的类中增加实例变量？能否向运行时创建的类中增加实例变量？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;不能向编译后得到的类中增加实例变量&lt;/li&gt;
&lt;li&gt;能向运行时创建的类中添加实例变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译后的类已经注册在 &lt;code&gt;runtime&lt;/code&gt; 中，类结构体中的 &lt;code&gt;objc_ivar_list&lt;/code&gt; 实例变量的链表和 &lt;code&gt;instance_size&lt;/code&gt; 实例变量的内存大小已经确定，同时 &lt;code&gt;runtime&lt;/code&gt; 会调用 &lt;code&gt;class_setWeakIvarLayout&lt;/code&gt; 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；&lt;/li&gt;
&lt;li&gt;运行时创建的类是可以添加实例变量，调用 &lt;code&gt;class_addIvar&lt;/code&gt; 函数。但是得在调用 &lt;code&gt;objc_allocateClassPair&lt;/code&gt; 之后，&lt;code&gt;objc_registerClassPair&lt;/code&gt; 之前，原因同上。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>什么时候会报unrecognized selector的异常？</title>
      <link>http://felixmlians.github.io/2014/06/22/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%8A%A5unrecognized-selector%E7%9A%84%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sun, 22 Jun 2014 19:59:51 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/22/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%8A%A5unrecognized-selector%E7%9A%84%E5%BC%82%E5%B8%B8/</guid>
      <description>&lt;p&gt;简单来说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objc&lt;/code&gt;是动态语言，每个方法在运行时会被动态转为消息发送，即：&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;objc&lt;/code&gt;在向一个对象发送消息时，&lt;code&gt;runtime&lt;/code&gt;库会根据对象的&lt;code&gt;isa&lt;/code&gt;指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常&lt;code&gt;unrecognized selector sent to XXX&lt;/code&gt; 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Method resolution&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;objc&lt;/code&gt;运行时会调用&lt;code&gt;+resolveInstanceMethod:&lt;/code&gt;或者 &lt;code&gt;+resolveClassMethod:&lt;/code&gt;，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Fast forwarding&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果目标对象实现了&lt;code&gt;-forwardingTargetForSelector:&lt;/code&gt;，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Normal forwarding&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这一步是Runtime最后一次给你挽救的机会。首先它会发送&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;消息获得函数的参数和返回值类型。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;返回nil，Runtime则会发出&lt;code&gt;-doesNotRecognizeSelector:&lt;/code&gt;消息，程序这时也就挂掉了。&lt;/p&gt;

&lt;p&gt;如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送&lt;code&gt;-forwardInvocation:&lt;/code&gt;消息给目标对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo 静态网站快速生成</title>
      <link>http://felixmlians.github.io/2014/06/21/hugo-%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90/</link>
      <pubDate>Sat, 21 Jun 2014 00:12:23 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/21/hugo-%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90/</guid>
      <description>

&lt;h4 id=&#34;安装:e5615f5477fd56f0fd7aa99a370a246f&#34;&gt;安装&lt;/h4&gt;

&lt;p&gt;如果说速度快是Hugo的第一大优点，那么安装简单应该就是Hugo的第二大优点。对于Mac用户，没有brew的话先安装brew，在命令行里敲：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再敲一行安装Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew new Hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以直接下载对应系统的binary文件，解压就行了:&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;建站:e5615f5477fd56f0fd7aa99a370a246f&#34;&gt;建站&lt;/h4&gt;

&lt;p&gt;首先建立自己的网站，mysite是网站的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入该路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该目录下你可以看到以下几个目录和config.toml文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ▸ archetypes/ 
 ▸ content/
 ▸ layouts/
 ▸ static/
   config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;config.toml是网站的配置文件，包括baseurl, title, copyright等等网站参数。&lt;/p&gt;

&lt;p&gt;这几个文件夹的作用分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes：包括内容类型，在创建新内容时自动生成内容的配置&lt;/li&gt;
&lt;li&gt;content：包括网站内容，全部使用markdown格式（/post）&lt;/li&gt;
&lt;li&gt;layouts：包括了网站的模版，决定内容如何呈现&lt;/li&gt;
&lt;li&gt;static：包括了css, js, fonts, media等，决定网站的外观&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hugo提供了一些完整的主题可以使用，下载这些主题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时现成的主题存放在themes/文件夹中。&lt;/p&gt;

&lt;p&gt;现在我们先熟悉一下Hugo，创建新页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入content/文件夹可以看到，此时多了一个markdown格式的文件about.md，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
+++
date = &amp;quot;2015-02-01T18:19:54+08:00&amp;quot;
draft = true
title = &amp;quot;about&amp;quot;

+++

contents here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我在页面中加入了主题，然后运行Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -t hyde --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-t参数的意思是使用hyde主题渲染我们的页面，注意到about.md目前是作为草稿，即draft参数设置为true，运行Hugo时要加上&amp;ndash;buildDrafts参数才会生成被标记为草稿的页面。 在浏览器输入localhost:1313，就可以看到我们刚刚创建的页面。&lt;/p&gt;

&lt;p&gt;注意观察当前目录下多了一个文件夹public/，这里面是Hugo生成的整个静态网站，如果使用Github pages来作为博客的Host，你只需要将public/里的文件上传就可以，这相当于是Hugo的输出。&lt;/p&gt;

&lt;h4 id=&#34;评论功能:e5615f5477fd56f0fd7aa99a370a246f&#34;&gt;评论功能&lt;/h4&gt;

&lt;p&gt;Hugo默认支持Disqus的评论，需要在模版中添加以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ template &amp;quot;_internal/disqus.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spf13在/layouts/partials/disqus.html中已经添加好了。
只需要去&lt;a href=&#34;https://disqus.com/&#34;&gt;Disqus&lt;/a&gt;注册一个账号，然后在config.toml里加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disqusShortname = &amp;quot;yourdisqusShortname&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;插入图片:e5615f5477fd56f0fd7aa99a370a246f&#34;&gt;插入图片&lt;/h4&gt;

&lt;p&gt;图片文件放在static/media文件中，插入图片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ % img src=&amp;quot;/media/example.jpg&amp;quot; alt=&amp;quot;example&amp;quot; %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的{{和%之间也加上了空格，避免这行代码起作用，实际使用也需要把空格去掉。&lt;/p&gt;

&lt;h4 id=&#34;官方网站:e5615f5477fd56f0fd7aa99a370a246f&#34;&gt;官方网站&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;Hugo 中文网站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;Hugo themes&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>统计 iOS 开发代码</title>
      <link>http://felixmlians.github.io/2014/06/20/%E7%BB%9F%E8%AE%A1-ios-%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 20 Jun 2014 18:45:12 +0800</pubDate>
      
      <guid>http://felixmlians.github.io/2014/06/20/%E7%BB%9F%E8%AE%A1-ios-%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81/</guid>
      <description>

&lt;h4 id=&#34;统计-ios-开发代码:d2832ab34fd5f8cc046f66037089c327&#34;&gt;统计 iOS 开发代码&lt;/h4&gt;

&lt;p&gt;如果要统计ios开发代码，包括头文件的，终端命令进入项目目录下，命令如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;find . -name &amp;quot;*.m&amp;quot; -or -name &amp;quot;*.h&amp;quot; -or -name &amp;quot;*.xib&amp;quot; -or -name &amp;quot;*.c&amp;quot; |xargs wc -l  
列出每个文件的行数&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;find . -name &amp;quot;*.m&amp;quot; -or -name &amp;quot;*.h&amp;quot; -or -name &amp;quot;*.xib&amp;quot; -or -name &amp;quot;*.c&amp;quot; |xargs grep -v &amp;quot;^$&amp;quot;|wc -l  
列出代码行数总和&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;grep -v &amp;ldquo;^$&amp;ldquo;是去掉空行;&lt;/p&gt;

&lt;p&gt;注释也统计在代码量之内，毕竟也一个字一个字码出来的;&lt;/p&gt;

&lt;p&gt;lipo -info xxxx.a    查看支持哪些构架&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>